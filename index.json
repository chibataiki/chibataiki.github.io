[{"content":"登陆机制相关文件:\n  groups\n  passwd\n  shaodow\n  /etc/group : user group file 用来分配用户组的文件权限?,通过:分为四个部分\n group name group password, x表示密码为空 group ID group包含的用户  Samples: root:\\x:0: daemon:\\x:1: adm:\\x:4:root,syslog /etc/passwd: use names 分为7个部分,通过:分隔\n  username\n  密码的hash值,或者 x表示密码存储在/etc/shadow中,! 表示passwd被锁定,不能通过密码登陆,但是可以通过(ssh key)登陆, *表示不允许登陆\n  uid\n  gid\n  注释\n  用户的home目录\n  (可选项) 用户的shell\n  sample:\nroot:\\x:0:0:Linux User,,,:/usr/share/ftp_server:/bin/sh ftp:*:95:95::/usr/share/ftp_server:/bin/sh sync:\\x:4:65534:sync:/bin:/bin/sync root:!:0:0:root:/tmp:/bin/ash games:\\x:5:60:games:/usr/games:/usr/sbin/nologin admin:$1$G555555$99999999999999/:500:500:admin:/tmp:/usr/bin/clish /etc/shadow : user password 只有特权用户可以访问,所以提高了密码的安全性,(这一点上很多嵌入式设备是直接将密码hash嵌入/etc/passwd中,所以不够安全)\n  login name\n  算法,salt和hash值 或者 特殊字符\n$id$salt$hashed\nid:\n $1$ – MD5 $2a$ – Blowfish $2y$ – Eksblowfish $5$ – SHA-256 $6$ – SHA-512    \u0026hellip; 和密码日期相关 略\n  sample:\nroot:$6$qQSEjrI$/krm4VuFwoD2CCbOSgN1ruZDP6esGKS1hoKNlEuagVDjzLMMwN9.:18394:0:99999:7::: referer:\nhttp://forums.dlink.com/index.php?PHPSESSID=jqcpi0ouvefltgp57unhp9jia4\u0026amp;topic=41475.0\nhttps://en.wikipedia.org/wiki/Linux_user_group\nhttps://en.wikipedia.org/wiki/Passwd#Shadow_file\n","description":"","id":0,"section":"todo","tags":[""],"title":"Linux Login","uri":"https://chibataiki.github.io/todo/linux-users-groups/"},{"content":"对于mips架构的busybox: 是动态链接的可执行文件, 执行时会加载对应的链接库\n$ rabin2 -l ./bin/busybox [Linked libraries] libsutil.so libgcc_s.so.1 libc.so.0 .\n最直接的方式是: chroot (change root)\ncp `which qemu-mips-static` ./ sudo chroot . ./qemu-mips-static ./bin/busybox 但是运行 /bin/sh 会出现问题:\n$ sudo chroot . ./qemu-mips-static ./bin/sh BusyBox v1.12.4 (2018-12-27 15:29:28 CST) built-in shell (ash) Enter 'help' for a list of built-in commands. # ls ./bin/sh: ls: not found # /bin/sh 执行典型的fork/execve 模式, execve被调用执行/bin/ls时,会尝试调用系统的ELF解释器加载程序,因此会调用失败.\n可以使用binfmt解决.\nTODO binfmt\n","description":"","id":1,"section":"todo","tags":["IoT","qemu"],"title":"Emulate Embedded Linux Device by Qemu","uri":"https://chibataiki.github.io/todo/emulate-embedded-linux-device-by-qemu/"},{"content":"firmwalker https://github.com/craigz28/firmwalker\n比较早的一个项目,bash编写,keywords patterns比较单薄\nstatic-firmware-analysis https://github.com/secjey/static-firmware-analysis\n灵感来自于firmwalker, 由python编写,比firmwalker多了一写匹配内容\ntrommel 也参考了firmwalker,由python编写,相比来说最为完善\n 细节  ","description":"","id":2,"section":"note","tags":["IoT"],"title":"嵌入式设备文件系统分析工具","uri":"https://chibataiki.github.io/note/embedded_device_filesystem_analyze/"},{"content":"Abstract first public, large-scale analysis of firmware images.\nunpacked 32 thousand firmware images into 1.7 million individual files\nshow the main benefits of look- ing at many different devices at the same time\ndiscovered a total of 38 previously unknown vulnerabilities in over 693 firmware images.\ncorrelating similar files inside apparently unrelated firmware images\n1. Introduction IoT devices:\n  Common- Off-The-Shelf (COTS) devices : printers, mobile phones, home routers, and computer components and peripherals.\n  less consumer oriented : video surveillance systems, medical implants, car elements, SCADA and PLC devices, anything electronics.\n  firmware definition:\nOld:\nThe term was originally introduced to describe the CPU microcode that existed “somewhere” between the hardware and the software layers.\nIEEE:\nIEEE Std 610.12-1990 [6] extended the definition to cover the “combination of a hardware device and computer instructions or computer data that reside as read-only software on the hardware device”.\nNow:\ndescribe the software that is embedded in a hard- ware device.\n关于人工分析和大规模自动化分析\n人工分析:结果精确,但对经验要求高,速度慢,难以进行大规模分析,难以评估整体的安全性\n自动化分析:xx\n漏洞的同源性:\n同一个承包商,或是使用同一工具,SDK, 不同品牌贴牌的同一产品\u0026hellip;\n1.1 Methodology static analysis scales better than dynamic analysis as it does not require access to the physi- cal devices.\ncollecting firmware images\nthe contribution of this paper :\nnot in the static analysis techniques we use (for example, we did not perform any static code analysis)\nbut to show the advantages of an horizontal, large-scale exploration.\nimplemented a correlation engine to compare and find similarities between all the objects in our dataset.\n1.2 result collected an initial set of 759,273 files (total 1.8TB of storage space) from publicly accessible firmware update sites.\nAfter filtering, left with 172,751 potential firmware images.\nsampled a set of 32,356 firmware candidates\nUsing a private cloud deployment of 90 worker nodes.\nautomatically discover and report 38 new vulnerabilities,\nconfirm several that were already known\n extracted private RSA keys and their self-signed certificates used in about 35,000 online devices several dozens of hard-coded password hashes. Most were week identified a number of possible backdoors such as the authorized_keys file a number of hard-coded telnetd credentials hard-coded web-login admin credentials a number of backdoor daemons and web pages  1.3 Contributions • We show the advantages of performing a large-scale analysis of firmware images and describe the main challenges associated with this activity.\n• We propose a framework to perform firmware collection, filtering, unpacking and analysis at large scale.\n• We implemented several efficient static techniques that we ran on 32, 356 firmware candidates.\n• We present a correlation technique which allows to propagate vulnerability information to similar firm- ware images.\n• We discovered 693 firmware images affected by at least one vulnerability and reported 38 new CVEs.\n2 challenge:   Building a Representative Dataset\n  Firmware Identification\n  Unpacking and Custom Formats\n  Scalability and Computational Limits\n  Results Confirmation\n  3.1 Architecture 3.2 Firmware Acquisition and Storage web crawler: from support pages; ftp server ;Google Custom Search Engines\n3.3 Unpacking and Analysis binwalk,FRAK ,Binary Analysis Toolkit (BAT)\npaper\u0026rsquo;s framework, (但是不开源,http://firmware.re/)\nPassword Hash Cracking use CUDA-enabled John The Ripper\n遇到硬编码hash认证的时候可以更快破解密码\n3.4 Correlation Engine Shared Credentials and Self-Signed Certificates\n(由于大量的OEM,对于嵌入式设备来说很常见)\nkeyword\nFuzzy hashes\n计算文件之间的相似度\n3.5 Data Enrichment 1.from: Shodan,Google Custom Search Engines\nby: web pages title , web servers authentication realms\n2.correlate SSL certificates (firmware,zmap)\n将两者的数据进行匹配,可以评估公网上易受漏洞影响的设备数量.\n4.2 result  Files Formats  ARM (63%) MIPS (7%) Vx- Works, Nucleus RTOS and Windows CE together: 7%.   Password Hashes Statistics  /etc/passwd /etc/shadow    Certificates and Private RSA Keys Statistics  Packaging Outdated and Vulnerable Software  old kernel old busybox \u0026hellip;   Building Images as root  (很多嵌入式设备,是没有权限管理的)   Web Servers Configuration  (同样很多web server的user是root)    ","description":"","id":3,"section":"paper","tags":[""],"title":"A Large-Scale Analysis of the Security of Embedded Firmwares","uri":"https://chibataiki.github.io/paper/a-large-scale-analysis-of-the-security-of-embedded-firmwares/"},{"content":"过滤 include:\nfiltername:\u0026quot;value\u0026quot;\nexclude: - or !\n-filtername:\u0026quot;value\u0026quot;\n筛选多值: , port: 22,23\nFilter: hash hash值为shodan data域的hash\nbanner text为空的时候,hash值为0\nhash:0 Filter: http.html_hash html的hash\n很多header存在Date值,此时使用hash值进行过滤就存在\n漏报,可以采用http.html的hash值进行过滤\nhttp.html_hash:[hash value] 其他过滤规则类似,可以看raw数据进行筛选\nfavicon hash值的计算 import mmh3 import requests response = requests.get('https://website/favicon.ico') favicon = response.content.encode('base64') hash = mmh3.hash(favicon) print(hash) CLI shodan提供cli接口\npython3 -m pip install shodan shodan download [quary] shodan parse --fields ip_str,port,[fields] --separator , [download_file] shodan search --fields ip_str,port,[fields] [quary] ... referer:\nhttps://help.shodan.io/mastery/property-hashes\nhttps://cli.shodan.io/\n","description":"","id":4,"section":"note","tags":["note"],"title":"shodan usage","uri":"https://chibataiki.github.io/note/shodan/"},{"content":"一种简单的密码加密机制:\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]){ if(argc==2){ printf(\u0026quot;Checking License: %s\\n\u0026quot;,argv[1]); int sum=0; for(int i=0;i\u0026lt;strlen(argv[1]);i++){ sum += (int)argv[1][i]; } // printf(\u0026quot;%d\\n\u0026quot;,sum); if( 1022 == sum){ printf(\u0026quot;Accessed!\u0026quot;); } else { printf(\u0026quot;Wrong!\u0026quot;); } }else { printf(\u0026quot;Usage: %s \u0026lt;key\u0026gt;\\n\u0026quot;,argv[0]); } return 0; } 其中1022 是 \u0026ldquo;THIS IS THE KEY\u0026rdquo; 进行简单的ascii值求和的结果.\n可以通过静态分析和逆向工程可以分析出加密机制.\nkey generator 根据逆向分析的算法生成注册码\nimport random def check_key(key): char_sum=0 for c in key: char_sum += ord(c) return char_sum chars=\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026quot; key = \u0026quot;\u0026quot; while True: key += random.choice(chars) sum_temp = check_key(key) if sum_temp \u0026gt; 1022: key = \u0026quot;\u0026quot; elif sum_temp \u0026lt;1022: pass else: print(\u0026quot;Key:{}\u0026quot;.format(key)) referer:\nyoutube channel: liveoverflow\n","description":"","id":5,"section":"todo","tags":["liveoverflow"],"title":"Simple_key_validation","uri":"https://chibataiki.github.io/todo/simple_key_validation/"},{"content":"  netzob\n可以对通讯协议逆向,建模并模糊测试\n  clusterfuzz\n可扩展的模糊测试基础结构，可发现软件中的安全性和稳定性问题。\n  ","description":"","id":6,"section":"todo","tags":[""],"title":"模糊测试工具","uri":"https://chibataiki.github.io/todo/fuzzing-tools/"},{"content":"netgear WNDR3700v4 存在命令注入漏洞,和认证绕过漏洞,相结合就可以未授权任意命令执行.\n使用固件版本: V1.0.1.42\n固件信息:\nLZMA compressed data \nSquashfs filesystem, little endian \nELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV)\n使用LZMA进行压缩,文件系统为Squashfs, MIPS32,big-end,使用system V 接口\n固件里一个/usr/sbin/net-cgi 程序里包含了很多功能,其中一个是 cmd_ping6(),如下:\n反编译一下大概就是:\nvoid cmd_ping6(char *target) { char cmd [132]; memset(cmd,0,0x80); sprintf(cmd,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target); system(cmd); return; } 这里先将参数target格式化到命令字符串内,并存储在栈中 sprintf(target,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target)\n因为sprintf 不检验长度,所以存在缓冲区溢出\n但是因为下面system函数直接调用了命令字符串,所以可以利用命令注入漏洞而不需要构造ROP链.\nsystem()将参数给/bin/sh进行调用, 所以target设置为: ; evid_command \u0026amp;\u0026gt; /dev/null\n那么执行完ping6 后,就会执行恶意命令.\n那么就要看如何控制传入cmd_ping6 的参数.\n交叉引用发现cgi_commit 调用了cmd_ping6\n而cgi_commit 则由loc_40535C: 调用, 而loc_40535C是apply.cgi MIME处理函数的一个输出.\n所以当向apply.cgi进行post请求,并且post数据包含submit_flag=ping6时,cgi_commit()就会调用cmd_ping6()\nCGI MIME:[TODO]\nhttp://speed.eik.bme.hu/help/html/Special_Edition-Using_CGI/ch10.htm#WhatisMIME\n参考链接\nhttps://shadow-file.blogspot.com/2013/10/complete-persistent-compromise-of.html\nhttps://shadow-file.blogspot.com/2013/10/netgear-root-compromise-via-command.html\n","description":"","id":7,"section":"posts","tags":["IoT"],"title":"Netgear-命令注入漏洞分析","uri":"https://chibataiki.github.io/posts/netgear_command_injection_vule_analysis/"},{"content":"404 now\n","description":"","id":8,"section":"gallery","tags":null,"title":"Temp","uri":"https://chibataiki.github.io/gallery/temp/"},{"content":"man 命令 看命令,函数的用法的时,可以使用man命令, man后面的数字参数代表手册的不同部分,如下:\n1.User Commands 2.System Calls 3.C Library Functions 4.Devices and Special Files 5.File Formats and Conventions 6.Games et. Al. 7.Miscellanea 8.System Administration tools and Deamons ","description":"","id":9,"section":"todo","tags":null,"title":"Unix-like 手册","uri":"https://chibataiki.github.io/todo/manual-pages/"},{"content":" gdb [program] [arguments]\n反汇编 main函数\n(gdb) disasseble main\n修改汇编模式,可以自己选择AT\u0026amp;T或者Intel, 也可以在.gdbinit中修改\n(gdb) set disassembly-flavor intel\n(gdb) set disassembly-flavor at\u0026amp;t\n(gdb) show disassembly-flavor\nAt\u0026amp;t : mov 0xc(%ebp),%eax\nIntel : mov eax, DWORD PTR [ebp+0xc]\n设置断点\n(gdb) break *main \n(gdb) b *0x000055555555468a \n运行\n(gdb) run\n继续运行\n(gdb) continue / c\n运行下条指令(如果调用函数,则进入函数)\n(gdb) stepi / si\n执行下一条指令(如果调用函数,执行完跳出)\n(gdb) nexti /ni\n显示寄存器信息\n(gdb) info registers /i r\n显示函数信息\n(gdb) info functions\n(gdb) set $rax=0x01 // 修改寄存器参数\n显示函数:\ninfo functions\n","description":"","id":10,"section":"note","tags":["tools"],"title":"GDB 使用note","uri":"https://chibataiki.github.io/note/gdb-user-note/"},{"content":"使用 match/replace proxy-\u0026gt;Options-\u0026gt; March and Replace\n可以使用regex或者literal\n然后HTTP history 页面下方会多出一栏 Auto-modifided request, 点进去就可以看到修改过后的 request\n插件 Logger++ This extension can be used to log the requests and responses made by all Burp tools, and display them in a sortable table. It can also save the logged data in CSV format.\nRequires Java version 7.\nHTTP Request Smuggler This is an extension for Burp Suite designed to help you launch HTTP Request Smuggling attacks. It supports scanning for Request Smuggling vulnerabilities, and also aids exploitation by handling cumbersome offset-tweaking for you.\nTODO: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn\nTurbo Intruder Sending large numbers of HTTP requests and analyzing the results.\n Fast - Turbo Intruder uses a HTTP stack hand-coded from scratch with speed in mind. As a result, on many targets it can seriously outpace even fashionable asynchronous Go scripts. Flexible - Attacks are configured using Python. This enables handling of complex requirements such as signed requests and multi-step attack sequences. Also, the custom HTTP stack means it can handle malformed requests that break other libraries. Scalable - Turbo Intruder can achieve flat memory usage, enabling reliable multi-day attacks. It can also be run in headless environments via the command line. Convenient - Boring results can be automatically filtered out by an advanced diffing algorithm adapted from Backslash Powered Scanner  TODO: https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack\nreferer: https://portswigger.net/bappstore\n","description":"","id":11,"section":"note","tags":null,"title":"Burpsuite使用note","uri":"https://chibataiki.github.io/note/burpsuite-note/"},{"content":"特性 MIPS和ARM 一样是RISC精简指令集\n延迟槽\nMIPS I 引入了延迟槽机制,以减少各种指令后流水线的阻塞.\nMIPS II 取消了延迟槽机制\nMIPS III 是MIPS II的一个后向兼容的扩展,并支持64位.\nMIPS \u0026hellip;\n指令格式 指令:32bits byte : 8bits word: 4bits, halfword: 2bits\nMIPS架构中, 指令分为三种类型,R型、I型和J型.\n寄存器    Register Number Conventional Name Usage     $0 $zero 硬编码为0   $1 $at 保留给汇编器   $2 - $3 $v0, $v1 保存函数返回值   $4 - $7 $a0 - $a3 存储参数   $8 - $15 $t0 - $t7 存储临时数据   $16 - $23 $s0 - $s7 保存寄存器,存储后面用到的数据   $24 - $25 $t8 - $t9 存储临时数据   $26 - $27 $k0 - $k1 为内核保留   $28 $gp 全局指针   $29 $sp 堆栈指针   $30 $fp 保存栈指针   $31 $ra 返回地址    算数指令 opt $dst, $src, [xx] : $dst = $src + [xx]\nxxu : unsgined integers\nxxi : immediate\n控制指令 分支 bxx $t0, $t1, lable: xx: eq : equal\nlt : larger than\nle : less than\ngt : greater than\nge : greater equal\nne : not equal\n跳转 j lable : 无条件跳转到lable\njr $t3 : jump register ,跳转到$t3所存地址上.\n子程序调用\n  jal sub_label : jump and link\n$ra \u0026lt;— PC+4\nPC = sub_label\n  jalr register : 跳转地址来自于寄存器\n$ra \u0026lt;— PC+4\nPC \u0026lt;— $register\n  load/ store 指令 只有load /store 可以访问内存\n其他指令都是通过寄存器寻址\n  load:\nlw register_dst ,RAM_src # RAM_source所在的word加载到寄存器中\nlb register_dst ,RAM_src # byte\nli\tregister_dst, value\n  store\nsw register_dst ,RAM_dst # 将寄存器值存到对应内存中\nsb register_source, RAM_dst\n  参考链接:\nhttps://uweb.engr.arizona.edu/~ece369/Resources/spim/MIPSReference.pdf\n","description":"","id":12,"section":"note","tags":["assembly"],"title":"MIPS汇编note","uri":"https://chibataiki.github.io/note/mips-assembly-note/"},{"content":" IDAFuzzy : https://github.com/Ga-ryo/IDAFuzzy\n在IDA中,对函数进行模糊搜索不是由友好,所以搜了一下,发现了IDAFuzzy  IDA pro 在macOS下安装的坑 和Windows中直接将插件拖到plugin目录不同, macOS的插件安装需要两步\n 将ida_fuzzy.py 文件放到 plugins 目录下 将ida_fuzzy.py 所依赖的包放到 python 目录下  可以看到/Applications/IDA Pro 7.0/ida.app/Contents/MacOS中的目录结构:\nchibataiki@chibataikis-MBP MacOS % tree -d -L 1 . . ├── cfg ├── dbgsrv ├── idc ├── ids ├── loaders ├── plugins ├── procs ├── python ├── sig └── til ","description":"","id":13,"section":"posts","tags":["tools"],"title":"macOS下IDA插件安装","uri":"https://chibataiki.github.io/posts/ida-note/"},{"content":"受漏洞影响的是D-link 路由器的一些型号, 这些固件由D-link 子公司Alpha Networks公司开发.\n只需要将浏览器User-Agent标志修改为：xmlset_roodkcableoj28840ybtide，再访问路由器IP地址，即可无需经过验证访问路由器的Web管理界面修改设备设置。\n该后门在路由器的web服务中实现.\nCraig Heffner 进行分析的时候,就首先将 /bin/webs 拖进IDA进行分析.\n首先查看web server 的型号:\nthttpd-alphanetworks/2.23应该是thttpd的修改版本,而alphanetworks是D-link的子公司.\nfunctions一栏里面很多alpha开头的函数,里面有个权限检查程序alpha_auth_check,可以分析一下.\n通过交叉引用搜索发现 alpha_httpd_parse_request调用了alpha_auth_check :\nalpha_httpd_parse_request调用部分:\nloc_41A420: move $a0, $s2 la $t9, alpha_auth_check nop jalr $t9 ; alpha_auth_check nop lw $gp, 0x2830+var_2820($sp) li $v1, 0xFFFFFFFF beq $v0, $v1, loc_41A4B0 li $a0, 0xFFFFFFFF 分析一下参数:\nalpha_auth_check的传入参数$a0在$s2中,而 alpha_auth_check返回值存储在$v0中, 然后\n $v0和$v1 (0xFFFFFFFF :-1)会进行比较, 相等就跳转到loc_41A4B0 结束函数.\nalpha_auth_check内:\n存在strstr,strcmp 和以及一个明显的硬编码字符串\n看一下strstr用法:\nNAME strstr, strcasestr - locate a substring DESCRIPTION The strstr() function finds the first occurrence of the substring needle in the string haystack. The terminating null bytes ('\\0') are not compared. RETURN VALUE These functions return a pointer to the beginning of the located substring, or NULL if the substring is not found. strstr参数: a1分别是\u0026quot;graphic/\u0026ldquo;和\u0026quot;public/\u0026quot;,而a0来自于与0xB8($s0),\n所以这里的操作:\n1.strstr(0xB8($s0),\u0026quot;graphic/\u0026quot;) \n2.strstr(0xB8($s0)\u0026quot;public/\u0026quot; ) \n3.strcmp(0xD0($s0),\u0026quot;xmlset_roodkcableoj28840ybtide)\n如果strcmp匹配,则直接结束函数,这里就绕过了认证.\n分析传入的字符串\n0xD0($s0) -\u0026gt; httpd_parse_request $s0\n通过搜索0XD0 ,可以追溯到httpd_parse_request内:\nloc_41488C: loc_41488C: la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; nop addiu $a1, (aUserAgent - 0x470000) # \u0026quot;User-Agent:\u0026quot; li $a2, 0xB la $t9, strncasecmp nop jalr $t9 ; strncasecmp # $v0 =strncasecmp(a0,a1=\u0026quot;User-Agent:\u0026quot;,a2=0xB) nop lw $gp, 0x48+var_30($sp) bnez $v0, loc_4148EC\t# if($v0!=0)\tjmp loc_4148EC\tmove $a0, $s0 ... addiu $s0, 0xB # $s0 = $s0+0xB move $a0, $s0 # MEM[$a0] = MEM[$s0] la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; # load address to a1?? [TODO] nop addiu $a1, (asc_46EC10 - 0x470000) # \u0026quot; \\t\u0026quot; # $a1 = \u0026quot;\\t\u0026quot; la $t9, strspn\tnop jalr $t9 ; strspn # $v0 = strspn(a0,a1) nop lw $gp, 0x48+var_30($sp)\taddu $s0, $v0 # $s0= $s0+ $v0 b loc_4150EC sw $s0, 0xD0($s2) # MEM[$s2+0xD0]:4 = $s0 大概分析了下,如果User-Agent里带有xmlset_roodkcableoj28840ybtide, 那么就可以绕过验证\nshodan 关键词: Server: thttpd-alphanetworks/2.23\n参考链接:\nhttp://www.devttys0.com/2013/10/reverse-engineering-a-d-link-backdoor/\n","description":"","id":14,"section":"posts","tags":["IoT"],"title":"Dlink Backdoor 分析记录","uri":"https://chibataiki.github.io/posts/dlink-backdoor-analysis/"},{"content":"环境\n宿主机: ubuntu 18.04 x86_64\n客户机: qemu运行的debian(wheey)\nMIPS/ARM的程序调试方式:\n 直接在宿主机上使用qemu 用户模式 在对应架构的debian虚拟机上运行,使用qemu-[mips/arm]-static的调试模式或者gdbserver都行  这里选择第二种\n2.1. 客户机安装qemu-user-static\n apt-get install qemu-user-static\n chroot . ./qemu-[arch]-static [-g port] [program]\n2.2. 客户机安装 gdbserver\nchroot . ./program gdbserver --attach pid 调试工具(宿主机):\n IDA\ndebugger里设置一下就行 gdb-multiatch  set architecture mips target remote [ip]:[port] gdb可以使用pwngdb,pedagdb等插件\n","description":"","id":15,"section":"posts","tags":["IoT"],"title":"MIPS/ARM 调试环境","uri":"https://chibataiki.github.io/posts/dynamic-analysis-for-mips-arm/"},{"content":" Past\nThink much, action little.\n  Now:\u2028Knowledge as action.\n ","description":"","id":16,"section":"","tags":null,"title":"About","uri":"https://chibataiki.github.io/about/"},{"content":"之前安装 Burpsuite的时候,需要的版本是JDK1.8,这次ghida则需要新版本\nlinux 可以使用`sudo update-alternatives --config java` 进行java版本的选择  macOS下则使用homebrew\nbrew tap homebrew/cask-versions brew install jenv 显示java 环境\n/usr/libexec/java_home -v  结果类似于\n13.0.2, x86_64:\t\u0026quot;OpenJDK 13.0.2\u0026quot;\t/Library/Java/JavaVirtualMachines/openjdk-13.0.2.jdk/Contents/Home 1.8.0_231, x86_64:\t\u0026quot;Java SE 8\u0026quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home 添加 jdk ,路径就是上面的结果\njenv add \u0026lt;jdk_path\u0026gt;  显示java版本信息:\njenv versions jenv -version 设置java环境:\njenv global [jdk version] jenv local [jdk version] 有问题可以运行\njenv doctor\n参考:\nhttps://gist.github.com/ntamvl/5f4dbaa8f68e6897b99682a395a44c2e\n","description":"","id":17,"section":"macos","tags":["tools"],"title":"MacOS 多版本java管理","uri":"https://chibataiki.github.io/macos/macos-multui-java-management/"},{"content":"IDA pro: 最强大的反汇编软件\nhopper: 适用于macOS和Linux的逆向工程工具，可进行反汇编，反编译和调试(调试仅支持macOS Mac，Windows和iOS（ARM）可执行文件。\nradare2: Radare2是一个开源工具，用于反汇编，调试，分析和处理二进制文件.\n基于CLI 但是有gui接口,cutter\nghidra: 美国国家安全局开发维护的逆向工程框架.包括反汇编，汇编，反编译，脚本编写等功能.\nOllyDbg: windows 平台下的逆向工具,用于反汇编,反编译, 调试,分析\nImmunityDbg: Immunity Debugger是OllyDbg v1.10的一个分支，它内置了对Python脚本等的支持。\ngdb GNU Project debugger\n pwngdb gef peda  burpsuite *nix command: file\nstrings\nobjdump\nhexdump\nstrace\nltrace\n\u0026hellip;\nchecksec\nbinwalk\n参考链接:\nhttps://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro\n","description":"","id":18,"section":"todo","tags":["tools","Reverse Engineering"],"title":"常用的漏洞分析工具note","uri":"https://chibataiki.github.io/todo/normal-binary-analysis-tools/"},{"content":"主要是对MIPS ARM架构的嵌入式设备进行仿真\n系统仿真在大多数时候并不是一种很好的选择,因为不能保证完美的仿真硬件\n0x00 QEMU 系统模式的仿真方式 系统模式下的引导需要提供内核,文件系统,文件系统使用binwalk等工具可以相对方便的获取,\n但是内核比较麻烦. 这里大致有三种系统仿真方式\n1.从设备中提取内核,并将提取出的文件系统制作成镜像,从镜像中启动. 这种方式最接近物理设备但是内核的提取不容易,是否能成功启动也另说.\n2.使用一个同架构(MIPS,ARM)预编译的内核,使用固件提取的文件做成镜像进行启动. 相对容易,但是让仿真成功进行也比较麻烦.\n3.使用一个同架构(MIPS,ARM)预编译的内核,以及预编译的系统镜像. 在系统成功启动后,将固件提取的文件系统拷贝到虚拟机中,使用 chroot 进行允许. 虽然不够贴近物理设备但是比较容易实现\n这里选择第3种.\n0x01 安装qemu sudo apt-get install qemu-system-mips qemu-system-mipsel qemu-system-arm -y (这里需要说一下的就是,直接使用apt 安装的qemub版本是2.x,但是QEMU官网的版本已经是4.x,\n里面一些manual 手册内容也发生了变化, 但是还有一种说法就是,最好不要自己编译QEMU,因为可能对某些支持不是很好)\n0x02下载预编译的kernel和系统文件镜像 下载链接: https://people.debian.org/~aurel32/qemu/\n一些默认设置:\nRoot password: root\nUser account: user\nUser password: user\n0x03启动qemu 最基础的命令:\nqemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026quot;root=/dev/sda1 console=ttyS0\u0026quot;  不想使用图形模式: -nographic\n默认内存128 可以设置 -m 256M\n0x04 网络配置 qemu支持设置usr,tap,bridge,l2tp,socket等类型的网络\n(! net 参数不提倡,QEMU建议使用netdev)\n1.用户模式- SLIRP 不加任何参数时的默认模式就是用户模式\n默认参数为 -net dev, -net nic\n网络如下图所示\n该模式允许客户机(qemu)和宿主机(ubuntu)进行有限的通讯\n-netdev user 中有一些设置参数比如:\nnet, host,dns,tftp,smb等等\n比较有用的是 hostfwd,允许进行数据转发\nhostfwd= [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\n例如宿主机通过ssh访问客户机:\nqemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22 其中-device e1000 创建虚拟网络设备\n-netdev user,id=net0,hostfwd=tcp::5555-:22\n创建user 模式的网络,将客户机所有端口22的数据重定向到宿主机端口5555上面\n在宿主机上ssh客户机就是:\nssh [username]@localhost -p 5555\n其他服务端口的开启类似.\n使用方式比较简单,\n但是可用性和性能方面都有很有限.\nTAP\u0026amp; TUN TAP等同于一个以太网设备，它操作第二层数据包(以太网数据帧)。 TUN 模拟了网络层设备,操作第三层数据包(IP数据)\ntap设备比user-mode 有更好的性能\n进行网络设置 先讲一下我的设备环境:\n 宿主机: macOS catalina 虚拟机: ubuntu 18.04.4 in VMware ubuntu 网络: 通过VMWare 的NAT接口连接   设置 bridge\n虚拟网桥工具\nsudo apt-get install bridge-utils\n  开启ipv4转发\n sudo sysctl net.ipv4.ip_forward=1\n  qemu-ifup \u0026amp;\u0026amp; qemu-ifdown\n  一些教程都是直接在 /network/interfaces 中直接修改的, 感觉方式不够优雅, 因为这些设置不是必须的,只有在仿真的时候才需要.\n所以这里设置一个build-bridge脚本执行网桥的设置和连接,一个recover-nerwork 脚本恢复网络,而qemu-ifup qemu-ifdown 设置tap相关设备(有需要优化的地方,因为有些时候ens33的ip存在没有释放的情况,[TODO])\nbuild-bridge\n # 判是否root 权限 if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Start building bridge... \u0026quot; dhclient -r ens33 # 释放ip ip addr flush ens33 # 清除 ip #确认ens3 刷新 ip link set dev ens33 down ip link set dev ens33 up ip link add name br0 type bridge #建立网桥 brctl addif br0 ens33 # 连接ens33 到bridge ip link set dev br0 up dhclient br0 # 从 dhcp 服务器获得 br0 的 IP 地址 ip addr flush ens33 echo \u0026quot;[!] Finisted bridge setting!\u0026quot;  recover-bridge\n判断root if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Recover network setting ... \u0026quot;\tip link set dev br0 down # 解除连接 brctl delif ens33 br0 # 删除tap 和 br0 ip link delete dev br0 dhclient ens33 sleep 1 ip link set dev ens33 up echo \u0026quot;[!]Finished network setting!\u0026quot;  qemu-ifup:\n$ip addr add 0.0.0.0 dev $1 $ip link set dev $1 up $brctl addif br0 $1  qemu-ifdown\nip link set dev $1 down btctl delif br0 $1 ip link delete dev $1    初步网络设置\nsudo ./build-bridge.sh\n  启动qemu\n  sudo qemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -net nic, -net tap 运行完的网络情况:\nbr0和ens33 tap0:\nqemu虚拟机里网络:\n网络测试\nQ\u0026amp;A:\nman qemu 中建议使用 netdev ,但是devtype 是什么没说\n-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]\nold way to create a new NIC and connect it to VLAN \u0026lsquo;n\u0026rsquo;\n(use the \u0026lsquo;-device devtype,netdev=str\u0026rsquo; option if possible instead)\nA: -net nic表示添加设备\n可以使用model=xxxx 指定添加设备的类型\nhttps://en.wikibooks.org/wiki/QEMU/Devices/Network\n参考链接\nhttps://people.debian.org/~aurel32/qemu/mipsel/README.txt\nhttps://manpages.debian.org/unstable/qemu-system-mips/qemu-system-mips.1.en.html\nhttps://wiki.qemu.org/Documentation/Networking#Tap\nhttps://odkq.com/qemukvmtap\n","description":"","id":19,"section":"posts","tags":["tools","IoT"],"title":"QEMU系统模式仿真","uri":"https://chibataiki.github.io/posts/qemu-system-mode-setting/"},{"content":"磊科路由器中内置了一个IGDMPTD的程序, 在外网上打开UDP端口53413 并进行监听.\n后门采用硬编码的密码,允许攻击者在路由器上执行任意代码.\n知道了这些之后,进行分析\n仿真:\n使用qemu 系统模式作为测试环境\n固件: https://github.com/rapid7/metasploit-framework/files/267284/vuln_squashfs-root.tar.gz\nscp -P 22 vuln_squashfs-root.tar.gz root@[target_ip]:/root tar xvf vuln_squashfs-root.tar.gz cd squashfs-root chroot . ./bin/igdmpt  可以看到端口已经打开\n使用poc可以发现确实存在漏洞\ncreate_server 函数中\nbind:\n int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` addr =[family][ip][port] = 0xa5d00002\n0xd05a = 53413 :端口号\n0x00 = 0 : ip , INADDR_ANY =0 ,监听所有地址\n0x02 = 2 :sa_family = 2,即SOCK_DGRAM ,表示UDP连接\n这里ip设置为监听所有地址,所以设备会被暴露在公网上,很危险.\n/* Socket types. */ #define SOCK_STREAM\t1\t/* stream (connection) socket\t*/ #define SOCK_DGRAM\t2\t/* datagram (conn.less) socket\t*/ # define INADDR_ANY ((unsigned long int) 0x00000000) ... # define INADDR_NONE 0xffffffff ... # define INPORT_ANY 0 ... 敏感功能:\nPoc脚本:https://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n参考链接:\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/netis-router-backdoor-patched-but-not-really/\nhttps://blog.knownsec.com/wp-content/uploads/2015/01/NetcoreNetis-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%8E%E9%97%A8%E5%BA%94%E6%80%A5%E6%A6%82%E8%A6%81.pdf\nhttps://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n","description":"","id":20,"section":"posts","tags":["IoT"],"title":"Netcore-igdmptd-后门漏洞分析","uri":"https://chibataiki.github.io/posts/netcore_igdmptd_backdoor_analysis/"},{"content":"环境： macOS catalina\nvim: macvim\n设置vim初始化环境 mkdir ~/.vim mv .vimrc ~/.vim/vimrc  vim的初始化环境在macOS上最初是～/.vimrc, 因为需要安装插件新建了.vim文件夹，所以想将.vimrc文件放入.vim目录下,这个时候需要重命名.vimrc为vimrc. 可以在:h viminfo 中查看\n安装插件 这里使用的是vim-plug :https://github.com/junegunn/vim-plug\n需要将\n\u0026quot; Plugins will be downloaded under the specified directory. call plug#begin('~/.vim/plugged') \u0026quot; List ends here. Plugins become visible to Vim after this call. call plug#end()  添加到vimrc中,然后vim下执行:PlugInstall 就可以安装配置中的插件\n安装markdown预览插件 https://github.com/iamcco/markdown-preview.nvim\n在vimrc Plug区域添加\ncall plug#begin('~/.vim/plugged')  预览:\n:MarkdownPreview :MarkdownPreviewStop  ","description":"","id":21,"section":"posts","tags":["tools"],"title":"Vim-Markdown-插件安装","uri":"https://chibataiki.github.io/posts/vim-markdown-plugin-install/"},{"content":"glitching 攻击的目标一般是硬件设备\n通过注入故障，使得正常运行的设备出现某种缺陷，然后利用这种缺陷尝试进行利用。\n大概的一些方式：\n1.对CPU时钟进行扰乱，比如加入额外的时钟周期\n2.将芯片的某些引脚接地\n3.突然提升设备的输入电压\n","description":"","id":22,"section":"todo","tags":["IoT"],"title":"Glitching Attack 故障注入攻击","uri":"https://chibataiki.github.io/todo/glitching_attack/"},{"content":"最基础的C代码\n #include\u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]){ for(int i = 0;i \u0026lt; argc; i++) { printf(\u0026quot;argument %d is %s\\n\u0026quot;,i,argv[i]); } return 0; } argc ：argument count 参数个数\nargv[] ：argument vector 参数数组\nargv[0] : 是程序本身\ncommand-line: ➜ ~ ./0x01 argument1 argument2 ...\nin c: argv[0] argv[1] argv[2] ...\n ➜ ~ ./0x01 1 2 3 argument 0 is ./0x01 argument 1 is 1 argument 2 is 2 argument 3 is 3 ","description":"","id":23,"section":"todo","tags":["liveoverflow"],"title":"A Simple Program in C","uri":"https://chibataiki.github.io/todo/a_simple_program_in_c/"},{"content":"因为有时候英文视频没有字幕，所以需要将视频的音频输出转为输入，这样可以借助一些翻译工具进行翻译。\n工具： Soundflower\n 安装 打开audio midi setup\ncreate Multi-Output Device，选中 Build-in Output 和SoundFlower(2ch),\n此时，sound中的Output就多了Multi-Output Device 项 chrome 浏览器下，translate.google.com 地址栏右侧microphone 设置可以选择 Internal-Microphone(Build-in)，以及Soundflower(2ch),此时 谷歌页面输入的声音就是此时电脑输出的声音  ","description":"","id":24,"section":"macos","tags":["tools"],"title":"macOS soundflower audio input-output","uri":"https://chibataiki.github.io/macos/macos_catalina_sound_redirection/"}]