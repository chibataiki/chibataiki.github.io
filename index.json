[{"content":"对于嵌入式设备系统的仿真,往往是前期比较难的一步.\n而是否选择仿真,以及仿真的程度也需要根据具体情况进行判断.\n仿真比较省钱,但是省钱的结果就是可能花费很多时间.\n对于单个二进制程序或者服务而言,比较方便的方式就是使用qemu的user-mode进行仿真,不过这种仿真也只适合于进行初步的测试.\n而实际进行实际的exploit的时候,因为涉及到的功能比较多,以及一些必要的外围设备参数,最好的方式还是物理设备.\n不过仿真的优势是适合进行大规模自动化分析,有几篇paper就是基于大规模的固件进行分析,这种研究视角相比于独立进行设备的分析就有所区别,可以获得一种更加宏观上的测试结果.\nreferer:\nhttps://www.thezdi.com/blog/2020/5/27/mindshare-how-to-just-emulate-it-with-qemu\n","description":"","id":0,"section":"note","tags":["emulation"],"title":"Why Need Emulation","uri":"https://chibataiki.github.io/note/why-need-emulation/"},{"content":"sslstrip is a MITM tool.\nhow it works People may not type https:// (http://) in the address bar.\noffen encouter SSL with this two types:\n 301/302 redirection click links with https://  sslstrip can watch http traffic and change all https links to http\narpspoof send ARP messages on LAN associate the attacker\u0026rsquo;s Mac address with the gateway ip, then all traffic will send too attacker\u0026rsquo;s machine\nsudo arpspoof -i [interface] -t [target] -r [gataway] 端口转发 sudo iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000 referer:\nhttps://github.com/moxie0/sslstrip\nhttps://www.youtube.com/watch?v=MFol6IMbZ7Y\nhttps://en.wikipedia.org/wiki/ARP_spoofing\n","description":"","id":1,"section":"note","tags":[""],"title":"Sslstrip Use Note","uri":"https://chibataiki.github.io/note/sslstrip-use-note/"},{"content":"一般而言,直接看官方文档就能解决很多问题, 但是实际测试中还是踩了很多坑,所以记录一下\n环境: ubuntu 20.04\n安装 坑: pip安装存在问题, 需要pipx\nhow mitm works https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/\ncertificate 安装mitmproxy的时候会在 .mitmproxy中默认生产很多认证相关的文件.\nubuntu需要手动信任一下\n 放到/usr/share/ca-certificates目录下 sudo dpkg-reconfigure ca-certificates  流量转发 开启转发:\nsysctl -w net.ipv4.ip_forward=1 sysctl -w net.ipv6.conf.all.forwarding=1 关闭 ICMP包的转发\nsysctl -w net.ipv4.conf.all.send_redirects=0 流量转发存在很多形式: https://docs.mitmproxy.org/stable/concepts-modes/\n这里讲一下 Transparent的相关问题\n选择本地转发的话:\n直接iptables 转发流量会遇到的一个问题就是循环转发\niptables -t nat -A OUTPUT -p tcp -dport 80 -j REDIRECT --to-port 8080\n这里8080是mitmproxy的代理端口, 所有出去的流量都会转发到8080,但是mitmproxy也需要访问80端口.\n所以一个解决方案是新建一个用户mitmproxyuser,让它执行mitmproxy, 然后iptables设置一下不要过滤用户:mitmproxyuser,就可以解决流量循环转发的问题\nsudo useradd mitmproxyuser passwd mitmproxyuser iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner mitmproxyuser -m multiport --dports 80,443 -j REDIRECT --to-port 8080 开启 mitmproxy su - mitmproxyuser mitmproxy --mode transparent --showhost --set block_global=false -k -s [script] referer:\nhttps://docs.mitmproxy.org/stable/\n","description":"","id":2,"section":"note","tags":[""],"title":"Mitmproxy Use Note","uri":"https://chibataiki.github.io/note/mitmproxy-use-note/"},{"content":"Ghidra plugin for ida ghidra包含了一些用于IDA的插件: 位于 ${GHIDRA_DIR}/Extensions/IDAPro/Python/\nmac下插件位置:  /Users/$USER/.idapro/plugins/\nxml_exporter.py: 1.a plugin to export an IDA database as an XML file.\n2.Place in the IDA plugins folder.\nxml_loader.py 1.an IDA loader to build a new database using an XML file.\n2.It loads the .bytes file and builds the IDA database using the contents of the XML file.\n3.NOTE: Currently, the loader does not support importing memory overlays or Harvard architectures (e.g., 8051).\n4.Place in the IDA loaders folder.\nxml_importer.py 1.a plugin to add data from an XML file to an existing database.\n2.It will NOT load any binary data from the bytes file.\n3.It will add symbols, comments, code, data, functions, etc. for addresses that currently exist in the database.\n4.Place in the IDA plugins folder.\nidaxml.py module 1.A require import for the xml_exporter, xml_importer, and xml_loader.\n2.Place in the IDA python folder. mac:  xxx/ida.app/Contents/MacOS/python\nreferer:\nhttps://revers3c.blogspot.com/2019/04/import-ida-pro-database-into-ghidra.html\n${GHIDRA_DIR}/Extensions/IDAPro/Python/{6,7}xx/README.html\n","description":"","id":3,"section":"note","tags":[""],"title":"Ghidra Usage Note","uri":"https://chibataiki.github.io/note/ghidra-usage-note/"},{"content":"对于IDA不能识别的二进制文件, 可以选择作为binary file 进行加载.\n需要:\n 手动设置CPU架构 手动设置加载基址  一旦IDA加载了文件,那么首先做的就是在最开头按下c, 将其转为code.\nIDA会将二进制文件的bytes转为code然后进行分析, 但是任然会存在很多没有解析的code.\n自动分析binary file 从固件中找到对应的符号文件, 使用IDApython进行符号的修复\nTODO referer:\nhttp://www.devttys0.com/2011/07/reverse-engineering-vxworks-firmware-wrt54gv8/\n","description":"","id":4,"section":"note","tags":[""],"title":"IDA_usage_note","uri":"https://chibataiki.github.io/note/ida_usage_note/"},{"content":"文件系统的提取 看第一篇参考文献的时候,尝试了下,找到了Tp_Link_wr886nv6的固件.\nbinwalk 扫描结果:\n考虑到wr886nv6的内存空间, 这个解压大小2M左右的lzma压缩文件就可能比较有意思.\n但是根据binwalk的两个文件初始位置进行分割会有点小问题,所以需要通过hex查看一下真实的有效数据是多大.\n类似于这样: 真实数据到 0x00b6b2就结束了\n000b6280: 500f 1765 1fee 46eb f9ca c213 2911 9afe P..e..F.....)... 000b6290: 3930 5afb 6f5c 6563 9742 d169 e313 e5ba 90Z.o\\ec.B.i.... 000b62a0: 030b ba40 fb20 2705 c2c4 64d9 fe98 78de ...@. '...d...x. 000b62b0: be68 ffff ffff ffff ffff ffff ffff ffff .h.............. ... 000b6ff0: ffff ffff ffff ffff ffff ffff ffff ffff ................ 000b7000: 4d49 4e49 4653 0000 0000 0000 0000 0000 MINIFS.......... 000b7010: 0000 0002 0000 0086 0001 f400 0007 557c ..............U| 000b7020: 921c 644e ae88 d9d2 2db4 48ce 5ceb 6951 ..dN....-.H.\\.iQ 所以实际的lzma文件\n1  dd if=wr886nv6.bin of=a200.lzma bs=1 skip=41472 count=746162 # 746162=0x000b62b0+2   IDA的加载 IDA无法直接识别文件,所以需要确定CPU架构和基址\n架构:\n通过 binwalk -Y获取结果:\n基址:\n通过strings对文件进行字符输出,可以看到:\n1 2 3 4 5 6  # Example: # mem -dump 80010000 1000 .... Show memory block start at 0x80010000 which size of 4k. 20065 # tftp -get 192.168.1.100 wr740nv5-cn.bin 80001000 .... 20066 # Download file wr740nv5-cn.bin from tftp server(192.168.1.100) to 20067 # local memory address 0x80001000.   应该就可以判断基址是0x80001000\n然后IDA设置一下CPU架构mipseb和基址.\n但是IDA打开之后,只进行了有限的自动分析,依然存在很多没有被分析的函数\n(TODO 可以尝试自己些IDApython 脚本)\n符号表的导入 通过对VxWorks关键词 bzero进行搜索(关键词来源? )\n1 2  ➜ grep -r bzero . Binary file ./C2E3A matches   独立符号文件特征:\n 1 00000000: 0001 f3fe 0000 139f 5400 0000 8017 c3d8 ........T....... 2 00000010: 5400 0006 8018 b8b0 5400 0014 8018 bef0 T.......T....... 3 00000020: 5400 0022 8018 b878 5400 002b 8018 c52c T..\u0026quot;...xT..+..., 4 00000030: 5400 0035 8017 c330 5400 0043 8018 000c T..5...0T..C.... 5 00000040: 5400 0051 8017 db8c 5400 0062 8018 14ec T..Q....T..b.... 6 00000050: 5400 0075 8001 8684 5400 0082 8001 8e04 T..u....T....... 7 00000060: 5400 0098 8017 f110 5400 00a4 8018 1604 T.......T....... 8 00000070: 5400 00b6 8018 1698 5400 00c9 8018 4bb8 T.......T.....K. 每8个bytes为一组, 然后第三第四的数值是递增的, 第5到第8字节和地址很像\ns\n编写IDApytho脚本 对symbol文件进行分析 可以看到,对符号名的描述从00000008开始, 而00009d00开始出现symbol对应的字符串.\n5400 0000 8017 c3d8 中:\n第0字节 54 表示类型(?)\n第1-3字节 00 0000表示symbol文件中的偏移\n第4-7字节8017 C3D8表示二进制文件对应的地址\n进入IDA后 8017C3D8 地址处 IDA并没有分析, 但是按c分析结果如下, 并且该函数名按照符号表对应为AddCA\nROM:8017C3D8 # --------------------------------------------------------------------------- ROM:8017C3D8 addiu $sp, -0x318 ROM:8017C3DC sw $ra, 0x310($sp) ROM:8017C3E0 sw $s7, 0x30C($sp) ROM:8017C3E4 sw $s6, 0x308($sp) ROM:8017C3E8 sw $s5, 0x304($sp) ROM:8017C3EC sw $s4, 0x300($sp) ... IDApython脚本:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  symfile =\u0026#34;xxx/xxxx/C2E3A\u0026#34; symbols_table_start_offset = 0x08 strings_table_start_offset = 0x9d00 with open(symfile, \u0026#34;rb\u0026#34;) as f: symfile_contents = f.read() # 获取symbol 相关数据 symbols_table = symfile_contents[symbols_table_start_offset:strings_table_start_offset] # 获取对应字符 strings_table = symfile_contents[strings_table_start_offset:] # strings 直接通过 \\x00 进行分割; def get_string_by_offset(offset): index = 0 while True: if strings_table[offset+index] != \u0026#34;\\x00\u0026#34;: index += 1 else: break return strings_table[offset:offset+index] # 将8个字节的symbol数据结构进行拆解 def get_symbols_metadata(): symbols = [] for offset in range(0, len(symbols_table), 8): symbol_item = symbols_table[offset:offset+8] flag = symbol_item[0] #第一个字节 string_offset = int(symbol_item[1:4].encode(\u0026#39;hex\u0026#39;), 16) # 2-4 bytes string_name = get_string_by_offset(string_offset) target_address = int(symbol_item[-4:].encode(\u0026#39;hex\u0026#39;), 16) #5-8 bytes symbols.append((flag, string_name, target_address)) return symbols def add_symbols(symbols): for flag, string_name, target_address in symbols: idc.MakeName(target_address, string_name) if flag ==\u0026#34;\\x54\u0026#34;: idc.MakeCode(target_address) idc.MakeFunction(target_address) if __name__ == \u0026#39;__main__\u0026#39;: symbols = get_symbols_metadata() add_symbols(symbols)   另一种方式:(如果严格一一对应的话,那么可以直接将strings直接通过\\x00进行split,然后对应起来)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  symfile =\u0026#34;xxxx/C2E3A\u0026#34; symbols_table_start_offset = 0x08 strings_table_start_offset = 0x9d00 with open(symfile, \u0026#34;rb\u0026#34;) as f: symfile_contents = f.read() # 获取symbol 相关数据 symbols_table = symfile_contents[symbols_table_start_offset:strings_table_start_offset] strings_table = symfile_contents[strings_table_start_offset:] symbol_strings = strings_table.split(chr(0)) def get_symbols_metadata(): symbols_metadata = [] num = 0 for offset in range(0, len(symbols_table), 8): symbol_item = symbols_table[offset:offset+8] flag = symbol_item[0] target_addr = int(symbol_item[-4:].encode(\u0026#39;hex\u0026#39;), 16) symbols_metadata.append((flag, symbol_strings[num], target_addr)) num += 1 return symbols_metadata def add_symbols(symbols_metadata): for flag, string_name, target_address in symbols_metadata: idc.MakeName(target_address, string_name) if flag ==\u0026#34;\\x54\u0026#34;: idc.MakeCode(target_address) idc.MakeFunction(target_address) symbols_metadata = get_symbols_metadata() add_symbols(symbols_metadata)   运行完之后符号已经修复了\nreferer:\n  http://galaxylab.com.cn/0x00-tp-link-wr886nv7-v1-1-0-%e8%b7%af%e7%94%b1%e5%99%a8%e5%88%86%e6%9e%90-%e5%9b%ba%e4%bb%b6%e5%88%9d%e6%ad%a5%e5%88%86%e6%9e%90/\n  https://cq674350529.github.io/2018/09/19/TP-Link-wr886v6-%E5%9B%BA%E4%BB%B6%E8%A7%A3%E6%9E%90/\n  https://blog.quarkslab.com/reverse-engineering-a-vxworks-os-based-router.html\n  ","description":"","id":5,"section":"note","tags":["vxworks"],"title":"Tp_Link_wr886nv6_VxWorks_firmware_analysis","uri":"https://chibataiki.github.io/note/tp-link_wr886nv6_vxworks_firmware_analysis/"},{"content":"rcS的含义:\nS : Single user mode,run level 1\nrc: run control\nrcS 通常是 shell script\nreferer:\nhttps://stackoverflow.com/questions/38934978/meaning-of-the-name-of-linuxs-rcs-script\nhttp://www.catb.org/~esr/writings/taoup/html/ch10s03.html\n","description":"","id":6,"section":"note","tags":["linux"],"title":"rcS_file","uri":"https://chibataiki.github.io/note/rcs_file/"},{"content":"介绍 Polypyus通过对相似二进制文件中已知函数的提取,从而对二进制文件函数进行定位.不需要对二进制文件进行反汇编(). 基于二进制的方式也使得运行速度很快. 但是缺点是需要很多相同架构,相同编译选项的二进制文件.\nPolypyus集成了一些现有的工具流程(Giidra, IDA, bindiff, Diaphora). 它可以将已经注释过的函数导入并从中学习,并将找出的函数导出到IDA中. Polypyus的门槛很高,因此只有在作者的实验中能够进行找到正确的匹配. 虽然不过强大但是 将匹配好的结果导入IDA中能够改善IDA的自动分析结果, 然后运行BinDiff\nBinDiff: 二进制文件的比较工具,帮助快速找到反汇编代码的相同点和不同点.\n解决的问题 IDA 6.8的自动分析比较激进,导致某些误报\nDIA 7.2则略保守,导致一些漏报\nBinDiff对于byte类型的函数,识别经常会出错. 但是Polupyus则对于byte类型函数识别的很精确.\n推测BinDiff的出错原因是: 由于函数的缺失和误报导致生成的控制流图有所不同.有时这些函数已经被DIA所识别,但是IDA不会认为这些是代码或者函数.\nAmnesia: ?\nAmnesia在找到很多函数的同时也找到了很多的误报. 但是,很多函数初试时设置的栈桢可能是相似的. 因此Polypyus有个设置: 可以通过带有注释的二进制输入文件去学习通用的函数起始地址,并在其他二进制文件中用来识别函数,而不需要匹配函数名.不过该设置只适用于之前没有确认出函数的区域,这样可以避免冲突.\n如何工作 Polypyus 收集带有注释的固件二进制文件,通过对共有的函数进行二进制模糊匹配.\n支持带注释的文件:\n WICED Studio 的 patch.elf 文件,包含symbol definition most ARM compilers 生成的 .symdefs 文件 .csv 文件  输入的二进制文件的共性越多,polypyus的效果越好.\n安装和使用 效果图:\n问题在于: annotated binary 哪来!\nreferer:\nhttps://github.com/seemoo-lab/polypyus\n","description":"","id":8,"section":"note","tags":[""],"title":"Polypyus_about","uri":"https://chibataiki.github.io/note/polypyus_about/"},{"content":"登陆机制相关文件:\n  groups\n  passwd\n  shaodow\n  /etc/group : user group file 用来分配用户组的文件权限?,通过:分为四个部分\n group name group password, x表示密码为空 group ID group包含的用户  Samples: root:\\x:0: daemon:\\x:1: adm:\\x:4:root,syslog /etc/passwd: use names 分为7个部分,通过:分隔\n  username\n  密码的hash值,或者 x表示密码存储在/etc/shadow中,! 表示passwd被锁定,不能通过密码登陆,但是可以通过(ssh key)登陆, *表示不允许登陆\n  uid\n  gid\n  注释\n  用户的home目录\n  (可选项) 用户的shell\n  sample:\nroot:\\x:0:0:Linux User,,,:/usr/share/ftp_server:/bin/sh ftp:*:95:95::/usr/share/ftp_server:/bin/sh sync:\\x:4:65534:sync:/bin:/bin/sync root:!:0:0:root:/tmp:/bin/ash games:\\x:5:60:games:/usr/games:/usr/sbin/nologin admin:$1$G555555$99999999999999/:500:500:admin:/tmp:/usr/bin/clish /etc/shadow : user password 只有特权用户可以访问,所以提高了密码的安全性,(这一点上很多嵌入式设备是直接将密码hash嵌入/etc/passwd中,所以不够安全)\n  login name\n  算法,salt和hash值 或者 特殊字符\n$id$salt$hashed\nid:\n $1$ – MD5 $2a$ – Blowfish $2y$ – Eksblowfish $5$ – SHA-256 $6$ – SHA-512    \u0026hellip; 和密码日期相关 略\n  sample:\nroot:$6$qQSEjrI$/krm4VuFwoD2CCbOSgN1ruZDP6esGKS1hoKNlEuagVDjzLMMwN9.:18394:0:99999:7::: referer:\nhttp://forums.dlink.com/index.php?PHPSESSID=jqcpi0ouvefltgp57unhp9jia4\u0026amp;topic=41475.0\nhttps://en.wikipedia.org/wiki/Linux_user_group\nhttps://en.wikipedia.org/wiki/Passwd#Shadow_file\n","description":"","id":9,"section":"note","tags":[""],"title":"Linux Login","uri":"https://chibataiki.github.io/note/linux-users-groups/"},{"content":"firmwalker https://github.com/craigz28/firmwalker\n比较早的一个项目,bash编写,keywords patterns比较单薄\nstatic-firmware-analysis https://github.com/secjey/static-firmware-analysis\n灵感来自于firmwalker, 由python编写,比firmwalker多了一写匹配内容\ntrommel 也参考了firmwalker,由python编写,相比来说最为完善\n 细节  ","description":"","id":10,"section":"note","tags":["IoT"],"title":"嵌入式设备文件系统分析工具","uri":"https://chibataiki.github.io/note/embedded_device_filesystem_analyze/"},{"content":"Abstract first public, large-scale analysis of firmware images.\nunpacked 32 thousand firmware images into 1.7 million individual files\nshow the main benefits of look- ing at many different devices at the same time\ndiscovered a total of 38 previously unknown vulnerabilities in over 693 firmware images.\ncorrelating similar files inside apparently unrelated firmware images\n1. Introduction IoT devices:\n  Common- Off-The-Shelf (COTS) devices : printers, mobile phones, home routers, and computer components and peripherals.\n  less consumer oriented : video surveillance systems, medical implants, car elements, SCADA and PLC devices, anything electronics.\n  firmware definition:\nOld:\nThe term was originally introduced to describe the CPU microcode that existed “somewhere” between the hardware and the software layers.\nIEEE:\nIEEE Std 610.12-1990 [6] extended the definition to cover the “combination of a hardware device and computer instructions or computer data that reside as read-only software on the hardware device”.\nNow:\ndescribe the software that is embedded in a hard- ware device.\n关于人工分析和大规模自动化分析\n人工分析:结果精确,但对经验要求高,速度慢,难以进行大规模分析,难以评估整体的安全性\n自动化分析:xx\n漏洞的同源性:\n同一个承包商,或是使用同一工具,SDK, 不同品牌贴牌的同一产品\u0026hellip;\n1.1 Methodology static analysis scales better than dynamic analysis as it does not require access to the physi- cal devices.\ncollecting firmware images\nthe contribution of this paper :\nnot in the static analysis techniques we use (for example, we did not perform any static code analysis)\nbut to show the advantages of an horizontal, large-scale exploration.\nimplemented a correlation engine to compare and find similarities between all the objects in our dataset.\n1.2 result collected an initial set of 759,273 files (total 1.8TB of storage space) from publicly accessible firmware update sites.\nAfter filtering, left with 172,751 potential firmware images.\nsampled a set of 32,356 firmware candidates\nUsing a private cloud deployment of 90 worker nodes.\nautomatically discover and report 38 new vulnerabilities,\nconfirm several that were already known\n extracted private RSA keys and their self-signed certificates used in about 35,000 online devices several dozens of hard-coded password hashes. Most were week identified a number of possible backdoors such as the authorized_keys file a number of hard-coded telnetd credentials hard-coded web-login admin credentials a number of backdoor daemons and web pages  1.3 Contributions • We show the advantages of performing a large-scale analysis of firmware images and describe the main challenges associated with this activity.\n• We propose a framework to perform firmware collection, filtering, unpacking and analysis at large scale.\n• We implemented several efficient static techniques that we ran on 32, 356 firmware candidates.\n• We present a correlation technique which allows to propagate vulnerability information to similar firm- ware images.\n• We discovered 693 firmware images affected by at least one vulnerability and reported 38 new CVEs.\n2 challenge:   Building a Representative Dataset\n  Firmware Identification\n  Unpacking and Custom Formats\n  Scalability and Computational Limits\n  Results Confirmation\n  3.1 Architecture 3.2 Firmware Acquisition and Storage web crawler: from support pages; ftp server ;Google Custom Search Engines\n3.3 Unpacking and Analysis binwalk,FRAK ,Binary Analysis Toolkit (BAT)\npaper\u0026rsquo;s framework, (但是不开源,http://firmware.re/)\nPassword Hash Cracking use CUDA-enabled John The Ripper\n遇到硬编码hash认证的时候可以更快破解密码\n3.4 Correlation Engine Shared Credentials and Self-Signed Certificates\n(由于大量的OEM,对于嵌入式设备来说很常见)\nkeyword\nFuzzy hashes\n计算文件之间的相似度\n3.5 Data Enrichment 1.from: Shodan,Google Custom Search Engines\nby: web pages title , web servers authentication realms\n2.correlate SSL certificates (firmware,zmap)\n将两者的数据进行匹配,可以评估公网上易受漏洞影响的设备数量.\n4.2 result  Files Formats  ARM (63%) MIPS (7%) Vx- Works, Nucleus RTOS and Windows CE together: 7%.   Password Hashes Statistics  /etc/passwd /etc/shadow    Certificates and Private RSA Keys Statistics  Packaging Outdated and Vulnerable Software  old kernel old busybox \u0026hellip;   Building Images as root  (很多嵌入式设备,是没有权限管理的)   Web Servers Configuration  (同样很多web server的user是root)    ","description":"","id":11,"section":"paper","tags":[""],"title":"A Large-Scale Analysis of the Security of Embedded Firmwares","uri":"https://chibataiki.github.io/paper/a-large-scale-analysis-of-the-security-of-embedded-firmwares/"},{"content":"过滤 include:\nfiltername:\u0026quot;value\u0026quot;\nexclude: - or !\n-filtername:\u0026quot;value\u0026quot;\n筛选多值: , port: 22,23\nFilter: hash hash值为shodan data域的hash\nbanner text为空的时候,hash值为0\nhash:0 Filter: http.html_hash html的hash\n很多header存在Date值,此时使用hash值进行过滤就存在\n漏报,可以采用http.html的hash值进行过滤\nhttp.html_hash:[hash value] 其他过滤规则类似,可以看raw数据进行筛选\nfavicon hash值的计算 import mmh3 import requests response = requests.get('https://website/favicon.ico') favicon = response.content.encode('base64') hash = mmh3.hash(favicon) print(hash) CLI shodan提供cli接口\npython3 -m pip install shodan shodan download [quary] shodan parse --fields ip_str,port,[fields] --separator , [download_file] shodan search --fields ip_str,port,[fields] [quary] ... referer:\nhttps://help.shodan.io/mastery/property-hashes\nhttps://cli.shodan.io/\n","description":"","id":12,"section":"note","tags":["note"],"title":"shodan usage","uri":"https://chibataiki.github.io/note/shodan/"},{"content":"一种简单的密码加密机制:\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]){ if(argc==2){ printf(\u0026quot;Checking License: %s\\n\u0026quot;,argv[1]); int sum=0; for(int i=0;i\u0026lt;strlen(argv[1]);i++){ sum += (int)argv[1][i]; } // printf(\u0026quot;%d\\n\u0026quot;,sum); if( 1022 == sum){ printf(\u0026quot;Accessed!\u0026quot;); } else { printf(\u0026quot;Wrong!\u0026quot;); } }else { printf(\u0026quot;Usage: %s \u0026lt;key\u0026gt;\\n\u0026quot;,argv[0]); } return 0; } 其中1022 是 \u0026ldquo;THIS IS THE KEY\u0026rdquo; 进行简单的ascii值求和的结果.\n可以通过静态分析和逆向工程可以分析出加密机制.\nkey generator 根据逆向分析的算法生成注册码\nimport random def check_key(key): char_sum=0 for c in key: char_sum += ord(c) return char_sum chars=\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026quot; key = \u0026quot;\u0026quot; while True: key += random.choice(chars) sum_temp = check_key(key) if sum_temp \u0026gt; 1022: key = \u0026quot;\u0026quot; elif sum_temp \u0026lt;1022: pass else: print(\u0026quot;Key:{}\u0026quot;.format(key)) referer:\nyoutube channel: liveoverflow\n","description":"","id":13,"section":"todo","tags":["liveoverflow"],"title":"Simple_key_validation","uri":"https://chibataiki.github.io/todo/simple_key_validation/"},{"content":"netgear WNDR3700v4 存在命令注入漏洞,和认证绕过漏洞,相结合就可以未授权任意命令执行.\n使用固件版本: V1.0.1.42\n固件信息:\nLZMA compressed data \nSquashfs filesystem, little endian \nELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV)\n使用LZMA进行压缩,文件系统为Squashfs, MIPS32,big-end,使用system V 接口\n固件里一个/usr/sbin/net-cgi 程序里包含了很多功能,其中一个是 cmd_ping6(),如下:\n反编译一下大概就是:\nvoid cmd_ping6(char *target) { char cmd [132]; memset(cmd,0,0x80); sprintf(cmd,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target); system(cmd); return; } 这里先将参数target格式化到命令字符串内,并存储在栈中 sprintf(target,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target)\n因为sprintf 不检验长度,所以存在缓冲区溢出\n但是因为下面system函数直接调用了命令字符串,所以可以利用命令注入漏洞而不需要构造ROP链.\nsystem()将参数给/bin/sh进行调用, 所以target设置为: ; evid_command \u0026amp;\u0026gt; /dev/null\n那么执行完ping6 后,就会执行恶意命令.\n那么就要看如何控制传入cmd_ping6 的参数.\n交叉引用发现cgi_commit 调用了cmd_ping6\n而cgi_commit 则由loc_40535C: 调用, 而loc_40535C是apply.cgi MIME处理函数的一个输出.\n所以当向apply.cgi进行post请求,并且post数据包含submit_flag=ping6时,cgi_commit()就会调用cmd_ping6()\nCGI MIME:[TODO]\nhttp://speed.eik.bme.hu/help/html/Special_Edition-Using_CGI/ch10.htm#WhatisMIME\nreferer:\nhttps://shadow-file.blogspot.com/2013/10/complete-persistent-compromise-of.html\nhttps://shadow-file.blogspot.com/2013/10/netgear-root-compromise-via-command.html\n","description":"","id":14,"section":"posts","tags":["IoT"],"title":"Netgear-命令注入漏洞分析","uri":"https://chibataiki.github.io/posts/netgear_command_injection_vule_analysis/"},{"content":" gdb [program] [arguments]\n反汇编 main函数\n(gdb) disasseble main\n修改汇编模式,可以自己选择AT\u0026amp;T或者Intel, 也可以在.gdbinit中修改\n(gdb) set disassembly-flavor intel\n(gdb) set disassembly-flavor at\u0026amp;t\n(gdb) show disassembly-flavor\nAt\u0026amp;t : mov 0xc(%ebp),%eax\nIntel : mov eax, DWORD PTR [ebp+0xc]\n设置断点\n(gdb) break *main \n(gdb) b *0x000055555555468a \n运行\n(gdb) run\n继续运行\n(gdb) continue / c\n运行下条指令(如果调用函数,则进入函数)\n(gdb) stepi / si\n执行下一条指令(如果调用函数,执行完跳出)\n(gdb) nexti /ni\n显示寄存器信息\n(gdb) info registers /i r\n显示函数信息\n(gdb) info functions\n(gdb) set $rax=0x01 // 修改寄存器参数\n显示函数:\ninfo functions\n","description":"","id":15,"section":"note","tags":["tools"],"title":"GDB 使用note","uri":"https://chibataiki.github.io/note/gdb-user-note/"},{"content":"使用 match/replace proxy-\u0026gt;Options-\u0026gt; March and Replace\n可以使用regex或者literal\n然后HTTP history 页面下方会多出一栏 Auto-modifided request, 点进去就可以看到修改过后的 request\n插件 Logger++ This extension can be used to log the requests and responses made by all Burp tools, and display them in a sortable table. It can also save the logged data in CSV format.\nRequires Java version 7.\nHTTP Request Smuggler This is an extension for Burp Suite designed to help you launch HTTP Request Smuggling attacks. It supports scanning for Request Smuggling vulnerabilities, and also aids exploitation by handling cumbersome offset-tweaking for you.\nTODO: https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn\nTurbo Intruder Sending large numbers of HTTP requests and analyzing the results.\n Fast - Turbo Intruder uses a HTTP stack hand-coded from scratch with speed in mind. As a result, on many targets it can seriously outpace even fashionable asynchronous Go scripts. Flexible - Attacks are configured using Python. This enables handling of complex requirements such as signed requests and multi-step attack sequences. Also, the custom HTTP stack means it can handle malformed requests that break other libraries. Scalable - Turbo Intruder can achieve flat memory usage, enabling reliable multi-day attacks. It can also be run in headless environments via the command line. Convenient - Boring results can be automatically filtered out by an advanced diffing algorithm adapted from Backslash Powered Scanner  TODO: https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack\nreferer: https://portswigger.net/bappstore\n","description":"","id":16,"section":"note","tags":null,"title":"Burpsuite使用note","uri":"https://chibataiki.github.io/note/burpsuite-note/"},{"content":"特性 MIPS和ARM 一样是RISC精简指令集\n延迟槽\nMIPS I 引入了延迟槽机制,以减少各种指令后流水线的阻塞.\nMIPS II 取消了延迟槽机制\nMIPS III 是MIPS II的一个后向兼容的扩展,并支持64位.\nMIPS \u0026hellip;\n指令格式 指令:32bits byte : 8bits word: 4bits, halfword: 2bits\nMIPS架构中, 指令分为三种类型,R型、I型和J型.\n寄存器    Register Number Conventional Name Usage     $0 $zero 硬编码为0   $1 $at 保留给汇编器   $2 - $3 $v0, $v1 保存函数返回值   $4 - $7 $a0 - $a3 存储参数   $8 - $15 $t0 - $t7 存储临时数据   $16 - $23 $s0 - $s7 保存寄存器,存储后面用到的数据   $24 - $25 $t8 - $t9 存储临时数据   $26 - $27 $k0 - $k1 为内核保留   $28 $gp 全局指针   $29 $sp 堆栈指针   $30 $fp 保存栈指针   $31 $ra 返回地址    算数指令 opt $dst, $src, [xx] : $dst = $src + [xx]\nxxu : unsgined integers\nxxi : immediate\n控制指令 分支 bxx $t0, $t1, lable: xx: eq : equal\nlt : larger than\nle : less than\ngt : greater than\nge : greater equal\nne : not equal\n跳转 j lable : 无条件跳转到lable\njr $t3 : jump register ,跳转到$t3所存地址上.\n子程序调用\n  jal sub_label : jump and link\n$ra \u0026lt;— PC+4\nPC = sub_label\n  jalr register : 跳转地址来自于寄存器\n$ra \u0026lt;— PC+4\nPC \u0026lt;— $register\n  load/ store 指令 只有load /store 可以访问内存\n其他指令都是通过寄存器寻址\n  load:\nlw register_dst ,RAM_src # RAM_source所在的word加载到寄存器中\nlb register_dst ,RAM_src # byte\nli\tregister_dst, value\n  store\nsw register_dst ,RAM_dst # 将寄存器值存到对应内存中\nsb register_source, RAM_dst\n  参考链接:\nhttps://uweb.engr.arizona.edu/~ece369/Resources/spim/MIPSReference.pdf\n","description":"","id":17,"section":"note","tags":["assembly"],"title":"MIPS汇编note","uri":"https://chibataiki.github.io/note/mips-assembly-note/"},{"content":" IDAFuzzy : https://github.com/Ga-ryo/IDAFuzzy\n在IDA中,对函数进行模糊搜索不是由友好,所以搜了一下,发现了IDAFuzzy  IDA pro 在macOS下安装的坑 和Windows中直接将插件拖到plugin目录不同, macOS的插件安装需要两步\n 将ida_fuzzy.py 文件放到 plugins 目录下 将ida_fuzzy.py 所依赖的包放到 python 目录下  可以看到/Applications/IDA Pro 7.0/ida.app/Contents/MacOS中的目录结构:\nchibataiki@chibataikis-MBP MacOS % tree -d -L 1 . . ├── cfg ├── dbgsrv ├── idc ├── ids ├── loaders ├── plugins ├── procs ├── python ├── sig └── til ","description":"","id":18,"section":"note","tags":["tools","ida"],"title":"macOS下IDA插件安装","uri":"https://chibataiki.github.io/note/ida-plugin-install/"},{"content":"受漏洞影响的是D-link 路由器的一些型号, 这些固件由D-link 子公司Alpha Networks公司开发.\n只需要将浏览器User-Agent标志修改为：xmlset_roodkcableoj28840ybtide，再访问路由器IP地址，即可无需经过验证访问路由器的Web管理界面修改设备设置。\n该后门在路由器的web服务中实现.\nCraig Heffner 进行分析的时候,就首先将 /bin/webs 拖进IDA进行分析.\n首先查看web server 的型号:\nthttpd-alphanetworks/2.23应该是thttpd的修改版本,而alphanetworks是D-link的子公司.\nfunctions一栏里面很多alpha开头的函数,里面有个权限检查程序alpha_auth_check,可以分析一下.\n通过交叉引用搜索发现 alpha_httpd_parse_request调用了alpha_auth_check :\nalpha_httpd_parse_request调用部分:\nloc_41A420: move $a0, $s2 la $t9, alpha_auth_check nop jalr $t9 ; alpha_auth_check nop lw $gp, 0x2830+var_2820($sp) li $v1, 0xFFFFFFFF beq $v0, $v1, loc_41A4B0 li $a0, 0xFFFFFFFF 分析一下参数:\nalpha_auth_check的传入参数$a0在$s2中,而 alpha_auth_check返回值存储在$v0中, 然后\n $v0和$v1 (0xFFFFFFFF :-1)会进行比较, 相等就跳转到loc_41A4B0 结束函数.\nalpha_auth_check内:\n存在strstr,strcmp 和以及一个明显的硬编码字符串\n看一下strstr用法:\nNAME strstr, strcasestr - locate a substring DESCRIPTION The strstr() function finds the first occurrence of the substring needle in the string haystack. The terminating null bytes ('\\0') are not compared. RETURN VALUE These functions return a pointer to the beginning of the located substring, or NULL if the substring is not found. strstr参数: a1分别是\u0026quot;graphic/\u0026ldquo;和\u0026quot;public/\u0026quot;,而a0来自于与0xB8($s0),\n所以这里的操作:\n1.strstr(0xB8($s0),\u0026quot;graphic/\u0026quot;) \n2.strstr(0xB8($s0)\u0026quot;public/\u0026quot; ) \n3.strcmp(0xD0($s0),\u0026quot;xmlset_roodkcableoj28840ybtide)\n如果strcmp匹配,则直接结束函数,这里就绕过了认证.\n分析传入的字符串\n0xD0($s0) -\u0026gt; httpd_parse_request $s0\n通过搜索0XD0 ,可以追溯到httpd_parse_request内:\nloc_41488C: loc_41488C: la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; nop addiu $a1, (aUserAgent - 0x470000) # \u0026quot;User-Agent:\u0026quot; li $a2, 0xB la $t9, strncasecmp nop jalr $t9 ; strncasecmp # $v0 =strncasecmp(a0,a1=\u0026quot;User-Agent:\u0026quot;,a2=0xB) nop lw $gp, 0x48+var_30($sp) bnez $v0, loc_4148EC\t# if($v0!=0)\tjmp loc_4148EC\tmove $a0, $s0 ... addiu $s0, 0xB # $s0 = $s0+0xB move $a0, $s0 # MEM[$a0] = MEM[$s0] la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; # load address to a1?? [TODO] nop addiu $a1, (asc_46EC10 - 0x470000) # \u0026quot; \\t\u0026quot; # $a1 = \u0026quot;\\t\u0026quot; la $t9, strspn\tnop jalr $t9 ; strspn # $v0 = strspn(a0,a1) nop lw $gp, 0x48+var_30($sp)\taddu $s0, $v0 # $s0= $s0+ $v0 b loc_4150EC sw $s0, 0xD0($s2) # MEM[$s2+0xD0]:4 = $s0 大概分析了下,如果User-Agent里带有xmlset_roodkcableoj28840ybtide, 那么就可以绕过验证\nshodan 关键词: Server: thttpd-alphanetworks/2.23\nreferer:\nhttp://www.devttys0.com/2013/10/reverse-engineering-a-d-link-backdoor/\n","description":"","id":19,"section":"posts","tags":["IoT"],"title":"Dlink Backdoor 分析记录","uri":"https://chibataiki.github.io/posts/dlink-backdoor-analysis/"},{"content":"环境\n宿主机: ubuntu 18.04 x86_64\n客户机: qemu运行的debian(wheey)\nMIPS/ARM的程序调试方式:\n 直接在宿主机上使用qemu 用户模式 在对应架构的debian虚拟机上运行,使用qemu-[mips/arm]-static的调试模式或者gdbserver都行  这里选择第二种\n2.1. 客户机安装qemu-user-static\n apt-get install qemu-user-static\n chroot . ./qemu-[arch]-static [-g port] [program]\n2.2. 客户机安装 gdbserver\nchroot . ./program gdbserver --attach pid 调试工具(宿主机):\n IDA\ndebugger里设置一下就行 gdb-multiatch  set architecture mips target remote [ip]:[port] gdb可以使用pwngdb,pedagdb等插件\nreferer:\n","description":"","id":20,"section":"posts","tags":["IoT"],"title":"MIPS/ARM 调试环境","uri":"https://chibataiki.github.io/posts/dynamic-analysis-for-mips-arm/"},{"content":" Past\nThink much, action little.\n  Now:\u2028Knowledge as action.\n ","description":"","id":21,"section":"","tags":null,"title":"About","uri":"https://chibataiki.github.io/about/"},{"content":"之前安装 Burpsuite的时候,使用的是旧版本JDK1.8,这次ghida需要新版本\n在linux中可以使用sudo update-alternatives --config java 进行java版本的选择\nmacOS下则使用jenv\nbrew tap homebrew/cask-versions brew install jenv 显示java 环境\n/usr/libexec/java_home -V 结果类似于\n13.0.2, x86_64:\t\u0026quot;OpenJDK 13.0.2\u0026quot;\t/Library/Java/JavaVirtualMachines/openjdk-13.0.2.jdk/Contents/Home 1.8.0_231, x86_64:\t\u0026quot;Java SE 8\u0026quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home 添加 jdk ,路径为就是上面现实的路径\njenv add \u0026lt;jdk_path\u0026gt; 显示java版本信息:\njenv versions jenv version 设置java环境:\njenv global [jdk version] jenv local [jdk version] 有问题可以运行 jenv doctor\nreferer:\nhttps://gist.github.com/ntamvl/5f4dbaa8f68e6897b99682a395a44c2e\n","description":"","id":22,"section":"macos","tags":["tools"],"title":"MacOS 多版本java管理","uri":"https://chibataiki.github.io/macos/macos-multui-java-management/"},{"content":"IDA pro: 最强大的反汇编软件\nhopper: 适用于macOS和Linux的逆向工程工具，可进行反汇编，反编译和调试(调试仅支持macOS Mac，Windows和iOS（ARM）可执行文件。\nradare2: Radare2是一个开源工具，用于反汇编，调试，分析和处理二进制文件.\n基于CLI 但是有gui接口,cutter\nghidra: 美国国家安全局开发维护的逆向工程框架.包括反汇编，汇编，反编译，脚本编写等功能.\nOllyDbg: windows 平台下的逆向工具,用于反汇编,反编译, 调试,分析\nImmunityDbg: Immunity Debugger是OllyDbg v1.10的一个分支，它内置了对Python脚本等的支持。\ngdb GNU Project debugger\n pwngdb gef peda  burpsuite *nix command: file\nstrings\nobjdump\nhexdump\nstrace\nltrace\n\u0026hellip;\nchecksec\nbinwalk\n参考链接:\nhttps://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro\n","description":"","id":23,"section":"todo","tags":["tools","Reverse Engineering"],"title":"常用的漏洞分析工具note","uri":"https://chibataiki.github.io/todo/normal-binary-analysis-tools/"},{"content":"主要是对MIPS/ARM架构的嵌入式设备进行仿真\n系统仿真在大多数时候并不是一种很好的选择,因为不能保证完美的仿真硬件\n0x00 QEMU 系统模式的仿真方式 系统模式下的引导需要提供内核,文件系统,文件系统使用binwalk等工具可以相对方便的获取,\n但是内核比较麻烦. 这里大致有三种系统仿真方式\n1.从设备中提取内核,并将提取出的文件系统制作成镜像,从镜像中启动. 这种方式最接近物理设备但是内核的提取不容易,是否能成功启动也另说.\n2.使用一个同架构(MIPS,ARM)预编译的内核,使用固件提取的文件做成镜像进行启动. 相对容易,但是让仿真成功进行也比较麻烦.\n3.使用一个同架构(MIPS,ARM)预编译的内核,以及预编译的系统镜像. 在系统成功启动后,将固件提取的文件系统拷贝到虚拟机中,使用 chroot 进行允许. 虽然不够贴近物理设备但是比较容易实现\n这里选择第3种.\n0x01 安装qemu sudo apt-get install qemu-system-mips qemu-system-mipsel qemu-system-arm -y (这里需要说一下的就是,直接使用apt 安装的qemub版本是2.x,但是QEMU官网的版本已经是4.x,\n里面一些manual 手册内容也发生了变化, 但是还有一种说法就是,最好不要自己编译QEMU,因为可能对某些支持不是很好)\n0x02下载预编译的kernel和系统文件镜像 下载链接: https://people.debian.org/~aurel32/qemu/\n一些默认设置:\nRoot password: root\nUser account: user\nUser password: user\n0x03启动qemu 最基础的命令:\nqemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026quot;root=/dev/sda1 console=ttyS0\u0026quot;  不想使用图形模式: -nographic\n默认内存128 可以设置 -m 256M\n0x04 网络配置 qemu支持设置usr,tap,bridge,l2tp,socket等类型的网络\n(! net 参数不提倡,QEMU建议使用netdev)\n1.用户模式- SLIRP 不加任何参数时的默认模式就是用户模式\n默认参数为 -net dev, -net nic\n网络如下图所示\n该模式允许客户机(qemu)和宿主机(ubuntu)进行有限的通讯\n-netdev user 中有一些设置参数比如:\nnet, host,dns,tftp,smb等等\n比较有用的是 hostfwd,允许进行数据转发\nhostfwd= [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\n例如宿主机通过ssh访问客户机:\nqemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22 其中-device e1000 创建虚拟网络设备\n-netdev user,id=net0,hostfwd=tcp::5555-:22\n创建user 模式的网络,将客户机所有端口22的数据重定向到宿主机端口5555上面\n在宿主机上ssh客户机就是:\nssh [username]@localhost -p 5555\n其他服务端口的开启类似.\n使用方式比较简单,\n但是可用性和性能方面都有很有限.\nTAP\u0026amp; TUN TAP等同于一个以太网设备，它操作第二层数据包(以太网数据帧)。 TUN 模拟了网络层设备,操作第三层数据包(IP数据)\ntap设备比user-mode 有更好的性能\n进行网络设置 先讲一下我的设备环境:\n 宿主机: macOS catalina 虚拟机: ubuntu 18.04.4 in VMware ubuntu 网络: 通过VMWare 的NAT接口连接   设置 bridge\n虚拟网桥工具\nsudo apt-get install bridge-utils\n  开启ipv4转发\n sudo sysctl net.ipv4.ip_forward=1\n  qemu-ifup \u0026amp;\u0026amp; qemu-ifdown\n  一些教程都是直接在 /network/interfaces 中直接修改的, 感觉方式不够优雅, 因为这些设置不是必须的,只有在仿真的时候才需要.\n所以这里设置一个build-bridge脚本执行网桥的设置和连接,一个recover-nerwork 脚本恢复网络,而qemu-ifup qemu-ifdown 设置tap相关设备(有需要优化的地方,因为有些时候ens33的ip存在没有释放的情况,[TODO])\nbuild-bridge\n # 判是否root 权限 if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Start building bridge... \u0026quot; dhclient -r ens33 # 释放ip ip addr flush ens33 # 清除 ip #确认ens3 刷新 ip link set dev ens33 down ip link set dev ens33 up ip link add name br0 type bridge #建立网桥 brctl addif br0 ens33 # 连接ens33 到bridge ip link set dev br0 up dhclient br0 # 从 dhcp 服务器获得 br0 的 IP 地址 ip addr flush ens33 echo \u0026quot;[!] Finisted bridge setting!\u0026quot;  recover-bridge\n判断root if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Recover network setting ... \u0026quot;\tip link set dev br0 down # 解除连接 brctl delif ens33 br0 # 删除tap 和 br0 ip link delete dev br0 dhclient ens33 sleep 1 ip link set dev ens33 up echo \u0026quot;[!]Finished network setting!\u0026quot;  qemu-ifup:\n$ip addr add 0.0.0.0 dev $1 $ip link set dev $1 up $brctl addif br0 $1  qemu-ifdown\nip link set dev $1 down btctl delif br0 $1 ip link delete dev $1    初步网络设置\nsudo ./build-bridge.sh\n  启动qemu\n  sudo qemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -net nic, -net tap 运行完的网络情况:\nbr0和ens33 tap0:\nqemu虚拟机里网络:\n网络测试\nQ\u0026amp;A:\nman qemu 中建议使用 netdev ,但是devtype 是什么没说\n-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]\nold way to create a new NIC and connect it to VLAN \u0026lsquo;n\u0026rsquo;\n(use the \u0026lsquo;-device devtype,netdev=str\u0026rsquo; option if possible instead)\nA: -net nic表示添加设备\n可以使用model=xxxx 指定添加设备的类型\nhttps://en.wikibooks.org/wiki/QEMU/Devices/Network\nreferer:\nhttps://people.debian.org/~aurel32/qemu/mipsel/README.txt\nhttps://manpages.debian.org/unstable/qemu-system-mips/qemu-system-mips.1.en.html\nhttps://wiki.qemu.org/Documentation/Networking#Tap\nhttps://odkq.com/qemukvmtap\n","description":"","id":24,"section":"posts","tags":["tools","IoT","qemu"],"title":"QEMU system mode emulation","uri":"https://chibataiki.github.io/posts/qemu-system-mode-setting/"},{"content":"磊科路由器中内置了一个IGDMPTD的程序, 在外网上打开UDP端口53413 并进行监听.\n后门采用硬编码的密码,允许攻击者在路由器上执行任意代码.\n知道了这些之后,进行分析\n仿真:\n使用qemu 系统模式作为测试环境\n固件: https://github.com/rapid7/metasploit-framework/files/267284/vuln_squashfs-root.tar.gz\nscp -P 22 vuln_squashfs-root.tar.gz root@[target_ip]:/root tar xvf vuln_squashfs-root.tar.gz cd squashfs-root chroot . ./bin/igdmpt  可以看到端口已经打开\n使用poc可以发现确实存在漏洞\ncreate_server 函数中\nbind:\n int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` addr =[family][ip][port] = 0xa5d00002\n0xd05a = 53413 :端口号\n0x00 = 0 : ip , INADDR_ANY =0 ,监听所有地址\n0x02 = 2 :sa_family = 2,即SOCK_DGRAM ,表示UDP连接\n这里ip设置为监听所有地址,所以设备会被暴露在公网上,很危险.\n/* Socket types. */ #define SOCK_STREAM\t1\t/* stream (connection) socket\t*/ #define SOCK_DGRAM\t2\t/* datagram (conn.less) socket\t*/ # define INADDR_ANY ((unsigned long int) 0x00000000) ... # define INADDR_NONE 0xffffffff ... # define INPORT_ANY 0 ... 敏感功能:\nPoc脚本:https://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n参考链接:\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/netis-router-backdoor-patched-but-not-really/\nhttps://blog.knownsec.com/wp-content/uploads/2015/01/NetcoreNetis-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%8E%E9%97%A8%E5%BA%94%E6%80%A5%E6%A6%82%E8%A6%81.pdf\nhttps://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n","description":"","id":25,"section":"posts","tags":["IoT"],"title":"Netcore-igdmptd-后门漏洞分析","uri":"https://chibataiki.github.io/posts/netcore_igdmptd_backdoor_analysis/"},{"content":"环境： macOS catalina\nvim: macvim\n设置vim初始化环境 mkdir ~/.vim mv .vimrc ~/.vim/vimrc  vim的初始化环境在macOS上最初是～/.vimrc, 因为需要安装插件新建了.vim文件夹，所以想将.vimrc文件放入.vim目录下,这个时候需要重命名.vimrc为vimrc. 可以在:h viminfo 中查看\n安装插件 这里使用的是vim-plug :https://github.com/junegunn/vim-plug\n需要将\n\u0026quot; Plugins will be downloaded under the specified directory. call plug#begin('~/.vim/plugged') \u0026quot; List ends here. Plugins become visible to Vim after this call. call plug#end()  添加到vimrc中,然后vim下执行:PlugInstall 就可以安装配置中的插件\n安装markdown预览插件 https://github.com/iamcco/markdown-preview.nvim\n在vimrc Plug区域添加\ncall plug#begin('~/.vim/plugged')  预览:\n:MarkdownPreview :MarkdownPreviewStop  ","description":"","id":26,"section":"note","tags":["tools"],"title":"Vim-Markdown-插件安装","uri":"https://chibataiki.github.io/note/vim-markdown-plugin-install/"},{"content":"因为有时候英文视频没有字幕，所以需要将视频的音频输出转为输入，这样可以借助一些翻译工具进行翻译。\n工具： Soundflower\n  安装\nhttps://github.com/mattingalls/Soundflower/releases\n  打开audio midi setup\ncreate Multi-Output Device，选中 Build-in Output 和SoundFlower(2ch),\n此时，sound中的Output就多了Multi-Output Device 项\n  chrome 浏览器下，translate.google.com 地址栏右侧microphone 设置可以选择 Internal-Microphone(Build-in)，以及Soundflower(2ch),此时 谷歌页面输入的声音就是此时电脑输出的声音\n  referer:\nhttps://github.com/mattingalls/Soundflower/releases\n","description":"","id":27,"section":"macos","tags":["tools"],"title":"macOS soundflower audio input-output","uri":"https://chibataiki.github.io/macos/macos_catalina_sound_redirection/"}]