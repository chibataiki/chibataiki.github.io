[{"content":" netzob\n可以对通讯协议逆向,建模并模糊测试  ","description":"","id":0,"section":"todo","tags":[""],"title":"模糊测试工具","uri":"https://chibataiki.github.io/todo/fuzzing-tools/"},{"content":"netgear WNDR3700v4 存在命令注入漏洞,和认证绕过漏洞,相结合就可以未授权任意命令执行.\n使用固件版本: V1.0.1.42\n固件信息:\nLZMA compressed data \nSquashfs filesystem, little endian \nELF 32-bit MSB executable, MIPS, MIPS32 version 1 (SYSV)\n使用LZMA进行压缩,文件系统为Squashfs, MIPS32,big-end,使用system V 接口\n固件里一个/usr/sbin/net-cgi 程序里包含了很多功能,其中一个是 cmd_ping6(),如下:\n反编译一下大概就是:\nvoid cmd_ping6(char *target) { char cmd [132]; memset(cmd,0,0x80); sprintf(cmd,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target); system(cmd); return; } 这里先将参数target格式化到命令字符串内,并存储在栈中 sprintf(target,\u0026quot;ping6 -c 1 %s \u0026gt; /tmp/ping6_result 2\u0026gt;\u0026amp;1\u0026quot;,target)\n因为sprintf 不检验长度,所以存在缓冲区溢出\n但是因为下面system函数直接调用了命令字符串,所以可以利用命令注入漏洞而不需要构造ROP链.\nsystem()将参数给/bin/sh进行调用, 所以target设置为: ; evid_command \u0026amp;\u0026gt; /dev/null\n那么执行完ping6 后,就会执行恶意命令.\n那么就要看如何控制传入cmd_ping6 的参数.\n交叉引用发现cgi_commit 调用了cmd_ping6\n而cgi_commit 则由loc_40535C: 调用, 而loc_40535C是apply.cgi MIME处理函数的一个输出.\n所以当向apply.cgi进行post请求,并且post数据包含submit_flag=ping6时,cgi_commit()就会调用cmd_ping6()\nCGI MIME:[TODO]\nhttp://speed.eik.bme.hu/help/html/Special_Edition-Using_CGI/ch10.htm#WhatisMIME\n参考链接\nhttps://shadow-file.blogspot.com/2013/10/complete-persistent-compromise-of.html\nhttps://shadow-file.blogspot.com/2013/10/netgear-root-compromise-via-command.html\n","description":"","id":1,"section":"posts","tags":["IoT"],"title":"Netgear-命令注入漏洞分析","uri":"https://chibataiki.github.io/posts/netgear_command_injection_vule_analysis/"},{"content":"在hugo上有些笔记被打了TODO标签, 所以需要搜索存在TODO 标记的md文件\n grep -r -i --include \\*.md 'string' ./ -r: recursively\n-i: ignore case\n\u0026ndash;include: all *.md file\n\u0026lsquo;string\u0026rsquo;: what to search\n./ : search path\n使用 find 和 grep 也可以.\nfind . -name \u0026quot;*.md\u0026quot; |xargs grep -i 'strings' ","description":"","id":2,"section":"notes","tags":["linux"],"title":"Grep Note","uri":"https://chibataiki.github.io/notes/grep-note/"},{"content":"404 now\n","description":"","id":3,"section":"gallery","tags":null,"title":"Temp","uri":"https://chibataiki.github.io/gallery/temp/"},{"content":" gdb [program] [arguments]\n反汇编 main函数\n(gdb) disasseble main\n修改汇编模式,可以自己选择AT\u0026amp;T或者Intel, 也可以在.gdbinit中修改\n(gdb) set disassembly-flavor intel\n(gdb) set disassembly-flavor at\u0026amp;t\n(gdb) show disassembly-flavor\nAt\u0026amp;t : mov 0xc(%ebp),%eax\nIntel : mov eax, DWORD PTR [ebp+0xc]\n设置断点\n(gdb) break *main \n(gdb) b *0x000055555555468a \n运行\n(gdb) run\n继续运行\n(gdb) continue / c\n运行下条指令(如果调用函数,则进入函数)\n(gdb) stepi / si\n执行下一条指令(如果调用函数,执行完跳出)\n(gdb) nexti /ni\n显示寄存器信息\n(gdb) info registers /i r\n显示函数信息\n(gdb) info functions\n(gdb) set $rax=0x01 // 修改寄存器参数\n显示函数:\ninfo functions\n","description":"","id":4,"section":"notes","tags":["tools"],"title":"GDB 使用note","uri":"https://chibataiki.github.io/notes/gdb-user-note/"},{"content":"使用 match/replace proxy-\u0026gt;Options-\u0026gt; March and Replace\n可以使用regex或者literal\n然后HTTP history 页面下方会多出一栏 Auto-modifided request, 点进去就可以看到修改过后的 request\n","description":"","id":5,"section":"notes","tags":null,"title":"Burpsuite使用note","uri":"https://chibataiki.github.io/notes/burpsuite-note/"},{"content":"特性 MIPS和ARM 一样是RISC精简指令集\n延迟槽\nMIPS I 引入了延迟槽机制,以减少各种指令后流水线的阻塞.\nMIPS II 取消了延迟槽机制\nMIPS III 是MIPS II的一个后向兼容的扩展,并支持64位.\nMIPS \u0026hellip;\n指令格式 指令:32bits byte : 8bits word: 4bits, halfword: 2bits\nMIPS架构中, 指令分为三种类型,R型、I型和J型.\n寄存器    Register Number Conventional Name Usage     $0 $zero 硬编码为0   $1 $at 保留给汇编器   $2 - $3 $v0, $v1 保存函数返回值   $4 - $7 $a0 - $a3 存储参数   $8 - $15 $t0 - $t7 存储临时数据   $16 - $23 $s0 - $s7 保存寄存器,存储后面用到的数据   $24 - $25 $t8 - $t9 存储临时数据   $26 - $27 $k0 - $k1 为内核保留   $28 $gp 全局指针   $29 $sp 堆栈指针   $30 $fp 保存栈指针   $31 $ra 返回地址    算数指令 opt $dst, $src, [xx] : $dst = $src + [xx]\nxxu : unsgined integers\nxxi : immediate\n控制指令 分支 bxx $t0, $t1, lable: xx: eq : equal\nlt : larger than\nle : less than\ngt : greater than\nge : greater equal\nne : not equal\n跳转 j lable : 无条件跳转到lable\njr $t3 : jump register ,跳转到$t3所存地址上.\n子程序调用\n  jal sub_label : jump and link\n$ra \u0026lt;— PC+4\nPC = sub_label\n  jalr register : 跳转地址来自于寄存器\n$ra \u0026lt;— PC+4\nPC \u0026lt;— $register\n  load/ store 指令 只有load /store 可以访问内存\n其他指令都是通过寄存器寻址\n  load:\nlw register_dst ,RAM_src # RAM_source所在的word加载到寄存器中\nlb register_dst ,RAM_src # byte\nli\tregister_dst, value\n  store\nsw register_dst ,RAM_dst # 将寄存器值存到对应内存中\nsb register_source, RAM_dst\n  参考链接:\nhttps://uweb.engr.arizona.edu/~ece369/Resources/spim/MIPSReference.pdf\n","description":"","id":6,"section":"notes","tags":["assembly"],"title":"MIPS汇编note","uri":"https://chibataiki.github.io/notes/mips-assembly-note/"},{"content":" IDAFuzzy : https://github.com/Ga-ryo/IDAFuzzy\n在IDA中,对函数进行模糊搜索不是由友好,所以搜了一下,发现了IDAFuzzy  IDA pro 在macOS下安装的坑 和Windows中直接将插件拖到plugin目录不同, macOS的插件安装需要两步\n 将ida_fuzzy.py 文件放到 plugins 目录下 将ida_fuzzy.py 所依赖的包放到 python 目录下  可以看到/Applications/IDA Pro 7.0/ida.app/Contents/MacOS中的目录结构:\nchibataiki@chibataikis-MBP MacOS % tree -d -L 1 . . ├── cfg ├── dbgsrv ├── idc ├── ids ├── loaders ├── plugins ├── procs ├── python ├── sig └── til ","description":"","id":7,"section":"posts","tags":["tools"],"title":"macOS下IDA插件安装","uri":"https://chibataiki.github.io/posts/ida-note/"},{"content":"受漏洞影响的是D-link 路由器的一些型号, 这些固件由D-link 子公司Alpha Networks公司开发.\n只需要将浏览器User-Agent标志修改为：xmlset_roodkcableoj28840ybtide，再访问路由器IP地址，即可无需经过验证访问路由器的Web管理界面修改设备设置。\n该后门在路由器的web服务中实现.\nCraig Heffner 进行分析的时候,就首先将 /bin/webs 拖进IDA进行分析.\n首先查看web server 的型号:\nthttpd-alphanetworks/2.23应该是thttpd的修改版本,而alphanetworks是D-link的子公司.\nfunctions一栏里面很多alpha开头的函数,里面有个权限检查程序alpha_auth_check,可以分析一下.\n通过交叉引用搜索发现 alpha_httpd_parse_request调用了alpha_auth_check :\nalpha_httpd_parse_request调用部分:\nloc_41A420: move $a0, $s2 la $t9, alpha_auth_check nop jalr $t9 ; alpha_auth_check nop lw $gp, 0x2830+var_2820($sp) li $v1, 0xFFFFFFFF beq $v0, $v1, loc_41A4B0 li $a0, 0xFFFFFFFF 分析一下参数:\nalpha_auth_check的传入参数$a0在$s2中,而 alpha_auth_check返回值存储在$v0中, 然后\n $v0和$v1 (0xFFFFFFFF :-1)会进行比较, 相等就跳转到loc_41A4B0 结束函数.\nalpha_auth_check内:\n存在strstr,strcmp 和以及一个明显的硬编码字符串\n看一下strstr用法:\nNAME strstr, strcasestr - locate a substring DESCRIPTION The strstr() function finds the first occurrence of the substring needle in the string haystack. The terminating null bytes ('\\0') are not compared. RETURN VALUE These functions return a pointer to the beginning of the located substring, or NULL if the substring is not found. strstr参数: a1分别是\u0026quot;graphic/\u0026ldquo;和\u0026quot;public/\u0026quot;,而a0来自于与0xB8($s0),\n所以这里的操作:\n1.strstr(0xB8($s0),\u0026quot;graphic/\u0026quot;) \n2.strstr(0xB8($s0)\u0026quot;public/\u0026quot; ) \n3.strcmp(0xD0($s0),\u0026quot;xmlset_roodkcableoj28840ybtide)\n如果strcmp匹配,则直接结束函数,这里就绕过了认证.\n分析传入的字符串\n0xD0($s0) -\u0026gt; httpd_parse_request $s0\n通过搜索0XD0 ,可以追溯到httpd_parse_request内:\nloc_41488C: loc_41488C: la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; nop addiu $a1, (aUserAgent - 0x470000) # \u0026quot;User-Agent:\u0026quot; li $a2, 0xB la $t9, strncasecmp nop jalr $t9 ; strncasecmp # $v0 =strncasecmp(a0,a1=\u0026quot;User-Agent:\u0026quot;,a2=0xB) nop lw $gp, 0x48+var_30($sp) bnez $v0, loc_4148EC\t# if($v0!=0)\tjmp loc_4148EC\tmove $a0, $s0 ... addiu $s0, 0xB # $s0 = $s0+0xB move $a0, $s0 # MEM[$a0] = MEM[$s0] la $a1, aNotPermitted # \u0026quot; not permitted.\\n\u0026quot; # load address to a1?? [TODO] nop addiu $a1, (asc_46EC10 - 0x470000) # \u0026quot; \\t\u0026quot; # $a1 = \u0026quot;\\t\u0026quot; la $t9, strspn\tnop jalr $t9 ; strspn # $v0 = strspn(a0,a1) nop lw $gp, 0x48+var_30($sp)\taddu $s0, $v0 # $s0= $s0+ $v0 b loc_4150EC sw $s0, 0xD0($s2) # MEM[$s2+0xD0]:4 = $s0 大概分析了下,如果User-Agent里带有xmlset_roodkcableoj28840ybtide, 那么就可以绕过验证\nshodan 关键词: Server: thttpd-alphanetworks/2.23\n参考链接:\nhttp://www.devttys0.com/2013/10/reverse-engineering-a-d-link-backdoor/\n","description":"","id":8,"section":"posts","tags":["IoT"],"title":"Dlink Backdoor 分析记录","uri":"https://chibataiki.github.io/posts/dlink-backdoor-analysis/"},{"content":"环境\n宿主机: ubuntu 18.04 x86_64\n客户机: qemu运行的debian(wheey)\nMIPS/ARM的程序调试方式:\n 直接在宿主机上使用qemu 用户模式 在对应架构的debian虚拟机上运行,使用qemu-[mips/arm]-static的调试模式或者gdbserver都行  这里选择第二种\n2.1. 客户机安装qemu-user-static\n apt-get install qemu-user-static\n chroot . ./qemu-[arch]-static [-g port] [program]\n2.2. 客户机安装 gdbserver\nchroot . ./program gdbserver --attach pid 调试工具(宿主机):\n IDA\ndebugger里设置一下就行 gdb-multiatch  set architecture mips target remote [ip]:[port] gdb可以使用pwngdb,pedagdb等插件\n","description":"","id":9,"section":"posts","tags":["IoT"],"title":"MIPS/ARM 调试环境","uri":"https://chibataiki.github.io/posts/dynamic-analysis-for-mips-arm/"},{"content":" Past\nThink much, action little.\n  Now:\u2028A journey of a thousand miles begins with a single step.\n ","description":"","id":10,"section":"","tags":null,"title":"About","uri":"https://chibataiki.github.io/about/"},{"content":"之前安装 Burpsuite的时候,需要的版本是JDK1.8,这次ghida则需要新版本\nlinux 可以使用`sudo update-alternatives --config java` 进行java版本的选择  macOS下则使用homebrew\nbrew tap homebrew/cask-versions brew install jenv 显示java 环境\n/usr/libexec/java_home -v  结果类似于\n13.0.2, x86_64:\t\u0026quot;OpenJDK 13.0.2\u0026quot;\t/Library/Java/JavaVirtualMachines/openjdk-13.0.2.jdk/Contents/Home 1.8.0_231, x86_64:\t\u0026quot;Java SE 8\u0026quot;\t/Library/Java/JavaVirtualMachines/jdk1.8.0_231.jdk/Contents/Home 添加 jdk ,路径就是上面的结果\njenv add \u0026lt;jdk_path\u0026gt;  显示java版本信息:\njenv versions jenv -version 设置java环境:\njenv global [jdk version] jenv local [jdk version] 有问题可以运行\njenv doctor\n参考:\nhttps://gist.github.com/ntamvl/5f4dbaa8f68e6897b99682a395a44c2e\n","description":"","id":11,"section":"tool","tags":["tools"],"title":"MacOS 多版本java管理","uri":"https://chibataiki.github.io/tool/macos-multui-java-management/"},{"content":"IDA pro:\nhopper:\n适用于macOS和Linux的逆向工程工具，可让进行反汇编，反编译和调试(调试仅支持macOS Mac，Windows和iOS（ARM）可执行文件。\n静态调试比较好? [TODO]\nradare2:\nRadare2是一个开源工具，用于反汇编，调试，分析和处理二进制文件.\n基于CLI 但是有gui接口,cutter\nghidra:\n美国国家安全局开发维护的逆向工程框架.包括反汇编，汇编，反编译，脚本编写等功能.ii\nOllyDbg:\nwindows 平台下的逆向工具,用于反汇编,反编译, 调试,分析\nImmunityDbg:\nImmunity Debugger是OllyDbg v1.10的一个分支，它内置了对Python脚本等的支持。\nburpsuite\nfile\nstrings\nobjdump\nhexdump\nstrace\nltrace\nchecksec\nbinwalk\nfirmadyne\ngdb 插件:\npwngdb gef peda\n参考链接:\nhttps://reverseengineering.stackexchange.com/questions/1817/is-there-any-disassembler-to-rival-ida-pro\n","description":"","id":12,"section":"todo","tags":["tools","Reverse Engineering"],"title":"常用的漏洞分析工具note","uri":"https://chibataiki.github.io/todo/normal-binary-analysis-tools/"},{"content":"主要是对MIPS ARM架构的嵌入式设备进行仿真\n系统仿真在大多数时候并不是一种很好的选择,因为不能保证完美的仿真硬件\n0x00 QEMU 系统模式的仿真方式 系统模式下的引导需要提供内核,文件系统,文件系统使用binwalk等工具可以相对方便的获取,\n但是内核比较麻烦. 这里大致有三种系统仿真方式\n1.从设备中提取内核,并将提取出的文件系统制作成镜像,从镜像中启动. 这种方式最接近物理设备但是内核的提取不容易,是否能成功启动也另说.\n2.使用一个同架构(MIPS,ARM)预编译的内核,使用固件提取的文件做成镜像进行启动. 相对容易,但是让仿真成功进行也比较麻烦.\n3.使用一个同架构(MIPS,ARM)预编译的内核,以及预编译的系统镜像. 在系统成功启动后,将固件提取的文件系统拷贝到虚拟机中,使用 chroot 进行允许. 虽然不够贴近物理设备但是比较容易实现\n这里选择第3种.\n0x01 安装qemu sudo apt-get install qemu-system-mips qemu-system-mipsel qemu-system-arm -y (这里需要说一下的就是,直接使用apt 安装的qemub版本是2.x,但是QEMU官网的版本已经是4.x,\n里面一些manual 手册内容也发生了变化, 但是还有一种说法就是,最好不要自己编译QEMU,因为可能对某些支持不是很好)\n0x02下载预编译的kernel和系统文件镜像 下载链接: https://people.debian.org/~aurel32/qemu/\n一些默认设置:\nRoot password: root\nUser account: user\nUser password: user\n0x03启动qemu 最基础的命令:\nqemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append \u0026quot;root=/dev/sda1 console=ttyS0\u0026quot;  不想使用图形模式: -nographic\n默认内存128 可以设置 -m 256M\n0x04 网络配置 qemu支持设置usr,tap,bridge,l2tp,socket等类型的网络\n(! net 参数不提倡,QEMU建议使用netdev)\n1.用户模式- SLIRP 不加任何参数时的默认模式就是用户模式\n默认参数为 -net dev, -net nic\n网络如下图所示\n该模式允许客户机(qemu)和宿主机(ubuntu)进行有限的通讯\n-netdev user 中有一些设置参数比如:\nnet, host,dns,tftp,smb等等\n比较有用的是 hostfwd,允许进行数据转发\nhostfwd= [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\n例如宿主机通过ssh访问客户机:\nqemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -device e1000,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:22 其中-device e1000 创建虚拟网络设备\n-netdev user,id=net0,hostfwd=tcp::5555-:22\n创建user 模式的网络,将客户机所有端口22的数据重定向到宿主机端口5555上面\n在宿主机上ssh客户机就是:\nssh [username]@localhost -p 5555\n其他服务端口的开启类似.\n使用方式比较简单,\n但是可用性和性能方面都有很有限.\nTAP\u0026amp; TUN TAP等同于一个以太网设备，它操作第二层数据包(以太网数据帧)。 TUN 模拟了网络层设备,操作第三层数据包(IP数据)\ntap设备比user-mode 有更好的性能\n进行网络设置 先讲一下我的设备环境:\n 宿主机: macOS catalina 虚拟机: ubuntu 18.04.4 in VMware ubuntu 网络: 通过VMWare 的NAT接口连接   设置 bridge\n虚拟网桥工具\nsudo apt-get install bridge-utils\n  开启ipv4转发\n sudo sysctl net.ipv4.ip_forward=1\n  qemu-ifup \u0026amp;\u0026amp; qemu-ifdown\n  一些教程都是直接在 /network/interfaces 中直接修改的, 感觉方式不够优雅, 因为这些设置不是必须的,只有在仿真的时候才需要.\n所以这里设置一个build-bridge脚本执行网桥的设置和连接,一个recover-nerwork 脚本恢复网络,而qemu-ifup qemu-ifdown 设置tap相关设备(有需要优化的地方,因为有些时候ens33的ip存在没有释放的情况,[TODO])\nbuild-bridge\n # 判是否root 权限 if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Start building bridge... \u0026quot; dhclient -r ens33 # 释放ip ip addr flush ens33 # 清除 ip #确认ens3 刷新 ip link set dev ens33 down ip link set dev ens33 up ip link add name br0 type bridge #建立网桥 brctl addif br0 ens33 # 连接ens33 到bridge ip link set dev br0 up dhclient br0 # 从 dhcp 服务器获得 br0 的 IP 地址 ip addr flush ens33 echo \u0026quot;[!] Finisted bridge setting!\u0026quot;  recover-bridge\n判断root if [ \u0026quot;$(id -u)\u0026quot; != \u0026quot;0\u0026quot; ]; then echo \u0026quot;This script must be run as root\u0026quot; 1\u0026gt;\u0026amp;2 exit 1 fi echo \u0026quot;[!]Recover network setting ... \u0026quot;\tip link set dev br0 down # 解除连接 brctl delif ens33 br0 # 删除tap 和 br0 ip link delete dev br0 dhclient ens33 sleep 1 ip link set dev ens33 up echo \u0026quot;[!]Finished network setting!\u0026quot;  qemu-ifup:\n$ip addr add 0.0.0.0 dev $1 $ip link set dev $1 up $brctl addif br0 $1  qemu-ifdown\nip link set dev $1 down btctl delif br0 $1 ip link delete dev $1    初步网络设置\nsudo ./build-bridge.sh\n  启动qemu\n  sudo qemu-system-mipsel -M malta -m 256M -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append 'root=/dev/sda1 console=ttyS0' -nographic -net nic, -net tap 运行完的网络情况:\nbr0和ens33 tap0:\nqemu虚拟机里网络:\n网络测试\nQ\u0026amp;A:\nman qemu 中建议使用 netdev ,但是devtype 是什么没说\n-net nic[,vlan=n][,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]\nold way to create a new NIC and connect it to VLAN \u0026lsquo;n\u0026rsquo;\n(use the \u0026lsquo;-device devtype,netdev=str\u0026rsquo; option if possible instead)\nA: -net nic表示添加设备\n可以使用model=xxxx 指定添加设备的类型\nhttps://en.wikibooks.org/wiki/QEMU/Devices/Network\n参考链接\nhttps://people.debian.org/~aurel32/qemu/mipsel/README.txt\nhttps://manpages.debian.org/unstable/qemu-system-mips/qemu-system-mips.1.en.html\nhttps://wiki.qemu.org/Documentation/Networking#Tap\nhttps://odkq.com/qemukvmtap\n","description":"","id":13,"section":"posts","tags":["tools","IoT"],"title":"QEMU系统模式仿真","uri":"https://chibataiki.github.io/posts/qemu-system-mode-setting/"},{"content":"磊科路由器中内置了一个IGDMPTD的程序, 在外网上打开UDP端口53413 并进行监听.\n后门采用硬编码的密码,允许攻击者在路由器上执行任意代码.\n知道了这些之后,进行分析\n仿真:\n使用qemu 系统模式作为测试环境\n固件: https://github.com/rapid7/metasploit-framework/files/267284/vuln_squashfs-root.tar.gz\nscp -P 22 vuln_squashfs-root.tar.gz root@[target_ip]:/root tar xvf vuln_squashfs-root.tar.gz cd squashfs-root chroot . ./bin/igdmpt  可以看到端口已经打开\n使用poc可以发现确实存在漏洞\ncreate_server 函数中\nbind:\n int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);` addr =[family][ip][port] = 0xa5d00002\n0xd05a = 53413 :端口号\n0x00 = 0 : ip , INADDR_ANY =0 ,监听所有地址\n0x02 = 2 :sa_family = 2,即SOCK_DGRAM ,表示UDP连接\n这里ip设置为监听所有地址,所以设备会被暴露在公网上,很危险.\n/* Socket types. */ #define SOCK_STREAM\t1\t/* stream (connection) socket\t*/ #define SOCK_DGRAM\t2\t/* datagram (conn.less) socket\t*/ # define INADDR_ANY ((unsigned long int) 0x00000000) ... # define INADDR_NONE 0xffffffff ... # define INPORT_ANY 0 ... 敏感功能:\nPoc脚本:https://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n参考链接:\nhttps://blog.trendmicro.com/trendlabs-security-intelligence/netis-router-backdoor-patched-but-not-really/\nhttps://blog.knownsec.com/wp-content/uploads/2015/01/NetcoreNetis-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%90%8E%E9%97%A8%E5%BA%94%E6%80%A5%E6%A6%82%E8%A6%81.pdf\nhttps://github.com/h00die/MSF-Testing-Scripts/blob/master/netis_backdoor.py\n","description":"","id":14,"section":"posts","tags":["IoT"],"title":"Netcore-igdmptd-后门漏洞分析","uri":"https://chibataiki.github.io/posts/netcore_igdmptd_backdoor_analysis/"},{"content":"交叉编译工具链 在一个系统上运行编译器,为另一个系统生成可执行文件,就需要交叉编译\n交叉编译可以使用交叉编译工具链和交叉编译库,在宿主机上编译一个架构不同的程序.\ntools buildroot\ncrosstool-NG\n","description":"","id":15,"section":"todo","tags":["IoT"],"title":"交叉编译工具链","uri":"https://chibataiki.github.io/todo/cross-compilation-tool-chain/"},{"content":"bootloader bootloader 是设备供电或者充值后执行的一段程序.\n设计概念:\n第一阶段:\n初始化硬件组件\n给第二阶段程序准备内存\n将程序copy到内存空间\n设置stack point\n进入第二阶段\n第二阶段:\n读取配置信息\n初始化这一阶段用到的硬件\n检验内存分布\n将kernel和fire system image copy 到RAM\n设置kernel boot 参数\nboot kernel\nkernel Device tree\nkernel\nfile system ","description":"","id":16,"section":"todo","tags":["IoT"],"title":"嵌入式设备boot过程","uri":"https://chibataiki.github.io/todo/embedded-device-boot-process/"},{"content":"环境： macOS catalina\nvim: macvim\n设置vim初始化环境 mkdir ~/.vim mv .vimrc ~/.vim/vimrc  vim的初始化环境在macOS上最初是～/.vimrc, 因为需要安装插件新建了.vim文件夹，所以想将.vimrc文件放入.vim目录下,这个时候需要重命名.vimrc为vimrc. 可以在:h viminfo 中查看\n安装插件 这里使用的是vim-plug :https://github.com/junegunn/vim-plug\n需要将\n\u0026quot; Plugins will be downloaded under the specified directory. call plug#begin('~/.vim/plugged') \u0026quot; List ends here. Plugins become visible to Vim after this call. call plug#end()  添加到vimrc中,然后vim下执行:PlugInstall 就可以安装配置中的插件\n安装markdown预览插件 https://github.com/iamcco/markdown-preview.nvim\n在vimrc Plug区域添加\ncall plug#begin('~/.vim/plugged')  预览:\n:MarkdownPreview :MarkdownPreviewStop  ","description":"","id":17,"section":"posts","tags":["tools"],"title":"Vim-Markdown-插件安装","uri":"https://chibataiki.github.io/posts/vim-markdown-plugin-install/"},{"content":"JDK安装 burpsuite是java程序，所以需要安装JDK\nJDK分为Oracle和OpenJDK，不做赘述，选择OpenJDK\n下载安装比较麻烦，所以选择homebrew安装\nbrew cask install java\n安装最新java会导致burpsuite安装失败\nbrew cask install java11 burpsuite 安装 下载burp-loader-keygen.jar 和 burpsuite_pro{version}.jar.\n如果看到出现: -Xbootclasspath/p 说明java版本太新,java8之后这个参数就移除了.\n解决方法一是使用旧版本JDK,二是自行对keygen进行patch.\n安装完java8 之后, 发现mac的keygen的license在每次切换窗口后都会变化,所以我就在虚拟机中运行了keygen程序,成功激活.\n证书 macOS下chrome安装:在safari下下载证书(使用burp监听端口), keychain Access 打开证书并手动信任\n参考链接:\nhttps://www.52pojie.cn/thread-1038295-1-1.html\n","description":"","id":18,"section":"tool","tags":["tools"],"title":"MacOS Catalina BurpSuite 安装","uri":"https://chibataiki.github.io/tool/macos-burpsuite-install/"},{"content":"glitching 攻击的目标一般是硬件设备，通过注入故障，使得正常运行的设备出现某种缺陷，然后利用这种缺陷尝试进行利用。\n大概的一些方式：\n1. 对CPU时钟进行扰乱，比如加入额外的时钟周期\n2. 将芯片的某些引脚接地\n3. 突然提升设备的输入电压\n","description":"","id":19,"section":"todo","tags":["IoT"],"title":"Glitching Attack 故障注入攻击","uri":"https://chibataiki.github.io/todo/glitching_attack/"},{"content":"macOS catalina下安装IDA报错\u0026rsquo;can\u0026rsquo;t be open\u0026rsquo;，进入ida包中运行\u0026rsquo;installbuilder.sh'报错显示\u0026rsquo;bad CPU type in executable:'，然后想到catalina已经不支持32位了，\n解决方式： 在mojava下安装，copy到catalina中可以直接使用\nhttps://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15\nhttps://www.52pojie.cn/thread-1063122-1-1.html\n","description":"","id":20,"section":"tool","tags":["tools"],"title":"MacOS Catalina下IDA安装问题","uri":"https://chibataiki.github.io/tool/macos_ida_install/"},{"content":"因为有时候英文视频没有字幕，所以需要将视频的音频输出转为输入，这样可以借助一些翻译工具进行翻译。\n工具： Soundflower\n 安装 打开audio midi setup\ncreate Multi-Output Device，选中 Build-in Output 和SoundFlower(2ch),\n此时，sound中的Output就多了Multi-Output Device 项 chrome 浏览器下，translate.google.com 地址栏右侧microphone 设置可以选择 Internal-Microphone(Build-in)，以及Soundflower(2ch),此时 谷歌页面输入的声音就是此时电脑输出的声音  ","description":"","id":21,"section":"tool","tags":["tools"],"title":"macOS下使用soundflower将音频输出转为输入","uri":"https://chibataiki.github.io/tool/macos_catalina_sound_redirection/"}]